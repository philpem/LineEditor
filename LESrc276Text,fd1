1REM todo:
2REM hook in correctly, something like:
3REM  if /^\s*\*<command>$/
4REM  if /^<command>$/ and option set
5REM  if /^\s*<command>$/ and option set (maybe)
6REM  what about colouring flags in completions?
7REM >LESrc276
8REM changes from 2.75:
9REM * don't make any assumptions about the ROM base address
10REM * fix a flags-preservation assumption (Snomatchatall)
11REM * fix dynamic area access rights
12REM * get input flags in R4 if on a 32-bit OS
13REM changes from 2.74:
14REM * some MOVS/LDM^ replaced
15REM * command line init moved from RMRun to RMLoad/RMReinit
16REM * 'better' case-insensitive comparison (Territory_UpperCaseTable)
17REM changes from 2.73:
18REM * OS_ReadLine password bit implemented (with sensible default character)
19REM * OS_ReadLine echo control bit implemented (won't echo ctrl chars when set)
20REM * SWI LineEditor_ReadLine
21REM * Error message if given an invalid buffer ID
22REM * Recognises A4/PC-AT keyboard '\' key
23REM changes from 2.72:
24REM * BASH-style don't store lines with leading spaces option
25REM * Command completion begun
26REM * SWI LineEditor_ReadInfo
27REM * more info returned by SWI LineEditor_ReadInfo
28REM * bugfix: cmd completion now matches pfxs to module cmd (eg r, ru -> run)
29REM * bugfix: fixed register corruption in checkrunpath
30REM * command completion now pretty much works
31REM in 2.72i:
32REM * root into instance structure
33REM * now free command completion structure when done with
34REM in 2.72j:
35REM * *LoadHistory now creates an instance if there isn't one already
36REM in 2.72k:
37REM * *LineEditor:re [tab] now completes to *LineEditor:Recall
38REM Added <LineEditor$PreString> and <LineEditor$PostString>
39REM Fixed erroneous "LineEditor in use" problem
40REM in 2.72l:
41REM ?
42REM in 2.72m:
43REM The archive for 2.72l had a LineEditor which reported 2.72k, but wasn't
44REM 2.72k or 2.72l
45REM in 2.72n:
46REM LineEditor$PreListString and ...Post...
47:
48ON ERROR PROCerr:END
49REM Need to fettle places where comments say !HACK! [case sens]
50vsn$="2.76d (R4-patch)":date$="15 Apr 2020":REM or MID$(TIME$,5,11)
51extra$=" "
52fnm$="LineEditor"
53TIME=0
54debug%=0
55trace%=0
56small=TRUE:REM TRUE makes module smaller by making help text less verbose
57cleverbeep%=1:REM don't use VDU7, but call SWI Sound_Control
58countclientbuf%=0:REM quick fix to stop quitting while client buffers exist
59oldrecall%=0:REM old recall list all buffers ; new just the current one
60unison_area_max_size=1024<<10: REM 1M
61IF RIGHT$(vsn$,1)<"0" OR RIGHT$(vsn$,1)>"9" OR debug% THEN extra$+=" [test version - don't distribute without permission]"
62IF debug% THEN extra$+=" [with debug code]"
63fkeybuff_len=256: REM buffer for fnkey expansion (RO uses 255, so this'll do)
64REM fkey workspc [ptr to next char][chars left][buffer - fkeybuff_len bytes]
65maxpathlen%=256:REM Maximum path length
66maxlen%=maxpathlen%
67REM =16:REM Word-rounded max leaf len inc. terminator eg "AUTOEXEC/BAT"
68bufsize%=1024:REM Buffer for leafnames in a directory (77*11 for ADFS)
69REM Code will read more leafnames if buffer is too small
70REM Ensure bufsize% can be loaded by MOV R0,#bufsize% (it can by default)
71REPEAT T%=bufsize%:WHILE(T%AND3)=0:T%=T%>>2:ENDWHILE:IF T%>=256 bufsize%+=4
72UNTIL T%<256
73bl$=CHR$0:cr$=CHR$13:lfcr$=CHR$10+cr$:tab$=CHR$9:esc$=CHR$27:hspc$=CHR$31
74codesize=&10000:DIM org codesize:L%=org+codesize
75swichunk=&83880:REM As allocated by Acorn
76CMD_alias=1
77CMD_command=2
78CMD_fileobj=3
79PROCinitdict
80P%=0:O%=org
81[OPT12
82.head&0
83; NB order of these 5, and offset from start of block, are relied upon...
84.bufsize & 0:.flags & 0:.minlen & 0:.maxlen & 0:.cursors & 0
85.upcasetable & 0
86.kbdtype & 0
87FNassert("bufsize=4")
88FNassert("flags=8")
89FNassert("minlen=12")
90FNassert("maxlen=16")
91FNassert("cursors=20")
92.pKernel & 0
93]
94IF countclientbuf% THEN
95[OPT12
96.clbufcnt & 0
97]
98ENDIF
99[OPT12
100.morebufs & 0 ; Buffers managed for other folks
101.tmp256 & 0 ; Scratch block
102.lastth & 0:.osver & 0:.sizeofheader]
103P%=0:O%=org:[OPT12; Instance -
104.cur     & 0 ; Current ptr into history buf (0 => inactive, -1 => bottom)
105.buf     & 0 ; pointer to start of history buffer
106.end     & 0 ; Current pointer to end of buffer
107.limit   & 0 ; pointer to end of history buffer ie maximum value of end
108.next    & 0 ; pointer to next instance in linked list
109.taskh   & 0 ; task handle (0 for not taskwindow) (-1 for client buffer)
110.cltaskh & 0 ; task handle tied to client buffer (0 or -1 means none)
111                ; only set for client buffer, so check taskh first
112.fkeybuf & 0 ; ptr to fnkey expansion (0 if none active)
113.match   & 0 ; length of initial segment to match for PageUp/PageDown
114.compcontext & 0 ; completion context structure
115.gbpbbuf & 0 ; -> buffer for OS_GBPB (0=>none allocated)
116.mtchbuf & 0 ; -> buffer for leaf match so far during filename completion
117.yankbuf & 0 ; -> buffer for yank-able text
118.r6      & 0 ; r6 for thingy
119.r7      & 0 ; r7 for thingy
120.pchar   & 0 ; password char
121.root    & 0 ; root for command completion tree
122; note should have buf <= cur <= end <= limit
123FNassert("buf=4")
124FNassert("end=8")
125FNassert("limit=12")
126FNassert("cur=0")
127.sizeofinst:]
128P%=0:O%=org:[OPT12; completion context
129.type    & 0
130.dirname & 0 ; -> buffer for path during filename completion
131.wildfnm & 0 ; -> buffer for wildcarded leaf we're trying to complete
132.context & 0 ; last R4 for OS_GBPB call (-ve => not in one)
133.match_s & 0
134.match_e & 0
135.sizeofcontext:]
136typeFile=0
137typeSysvar=1
138typeFS=2
139typeCmd=3
140REM Buffer Structure:
141REM
142REM   #####]\rLine 1\rLine 2\rLine n\0           [#####
143REM    buf->     cur->           end->    limit->
144REM
145REM   mincur->              maxcur->
146REM
147REM For an empty buffer:
148REM
149REM  #####]\0                                   [#####
150REM   buf->                              limit->
151REM   cur->
152REM     end->
153prog$="Line Editor"
154XOS_WriteC=&20000:XOS_WriteS=&20001:XOS_Write0=&20002:XOS_NewLine=&20003
155XOS_ReadC=&20004:XOS_Byte=&20006:XOS_GBPB=&2000C:XOS_WriteN=&20046
156XOS_WriteI=&20100
157XWimp_ReadSysInfo=&600F2:XWimp_SendMessage=&600E7
158ReadLineV=14:REM OS_ReadLine vector number
159C_bit=1<<29:V_bit=1<<28
160sp=13:REM stack pointer
161REM flags in bits 8-23 of R8
162fEchoBuf=1<<20
163fPasswd=1<<19
164fKeep4D=1<<18:REM Modified leaves compcontext alone
165fShowComp=1<<17:REM Set iff show list of completions (fTcsh set => comp 1st)
166fCompRev=1<<16:REM Set if it was Shift-Ctrl-Tab rather than Shift-Tab
167fTcsh=1<<15:REM Set/clear before calling completefnm
168fTaskwndw%=1<<14:REM TRUE iff in taskwindow
169fCopying=1<<13
170fAbbrev%=1<<12:REM used by filename completion to flag to try *Acc.Fred case
171fEsc%=1<<11:fEdit%=1<<10:fOver%=1<<9:fCopy%=1<<8
172dfltsize=4:REM EdSize default = 4K
173fAll%=fAbbrev% OR fEsc% OR fEdit% OR fOver% OR fCopy% OR fCopying
174REM These are in [R12,#flags]
175f_LocalHist = %1
176f_TrailDots = %10
177f_DfltOver  = %100
178f_KeepDupl  = %1000
179f_NoTildes  = %10000
180f_NoEvents  = %100000
181f_NoHatRepl = %1000000
182f_NoLeadSpc = %10000000
183FOR A%=%1100 TO %1110 STEP %0010
184P%=0:O%=org
185[OPT A%
186;label          OP      args              ; Comment
187                & 0
188                & init              ; Initialisation entry
189                & finalise          ; Finalisation entry
190                & servicecall       ; Service call entry
191                & titlestring       ; -> Title string
192                & helpstring        ; -> Help string
193                & keywordtable      ; -> Help/Command keyword table
194                & swichunk          ; And now SWIs...
195                & swihandler
196                & switab
197                & 0
198                & 0
199                & modflags
200.modflags       & 1
201.erasehisthelp  ADR     R0,szerasehisthelp
202                ADR     R2,szerasehistory
203.pprinthelpsyn  MOV     R5,R14
204                BL      pprinthelp
205                ADR     R0,syntax0args
206                BL      pprinthelp
207                MOV     PC,R5
208.recallhelp     ADR     R0,szrecallhelp
209                ADR     R2,szrecall
210                B       pprinthelpsyn
211.edstatushelp   ADR     R0,szedstatushelp
212                ADR     R2,szedstatus
213                B       pprinthelpsyn
214.ukswitok       & &1E6
215                = "BadSWI"+bl$
216.helpstring    := prog$+tab$+vsn$+" ("+date$+")"+extra$+"  Olly Betts"+bl$
217.syntax0args   := esc$+CHR$1+bl$    ; "Syntax; *<...>"
218FNalign ; so syntax1fnm can be reached by ADRs
219.syntax1fnm    := esc$+CHR$27+bl$   ; "Syntax; *<...> <filename>"
220.szerasehisthelp
221FNpp("*EraseHistory erases the contents of the history buffer."+cr$+bl$)
222.szrecallhelp
223FNpp("*Recall displays the current contents of the history buffer."+cr$+bl$)
224.szedstatushelp
225FNpp("*EdStatus displays details of the current history buffer usage."+cr$+bl$)
226.szloadhisthelp
227FNpp("*LoadHistory loads a saved history file."+cr$+bl$)
228.szsavehisthelp
229FNpp("*SaveHistory saves the current history into a file."+cr$+bl$)
230.switab
231.titlestring   := "LineEditor"+bl$
232                = "SetOptions"+bl$
233                = "GetOptions"+bl$
234                = "CreateBuffer"+bl$
235                = "DeleteBuffer"+bl$
236                = "SetPos"+bl$
237                = "GetPos"+bl$
238                = "GetLine"+bl$
239                = "AppendLine"+bl$
240                = "DeleteLine"+bl$
241                = "ReadInfo"+bl$
242                = "ReadLine"+bl$
243]
244IF debug% [OPTA%:="X"+bl$:]:REM Debugging SWI - does *Recall on buffer
245[OPTA%
246                = 0
247FNalign
248.loadhisthelp   ADR     R0,szloadhisthelp
249                ADR     R2,szloadhist
250                B       pprinthelpsyn1
251.savehisthelp   ADR     R0,szsavehisthelp
252                ADR     R2,szsavehist
253.pprinthelpsyn1 MOV     R5,R14
254                BL      pprinthelp
255                ADR     R0,syntax1fnm
256                MOV     R1,#0
257                SWI     "XOS_PrettyPrint"
258                SUBS    R0,R0,R0
259                MOV     PC,R5
260.ukswi          ADR     R0,ukswitok
261                MOV     R1,#0
262                MOV     R2,#0
263                ADR     R4,titlestring
264                MOV     R10,R14              ; Bug-fix to code in PRM
265                SWI     "XMessageTrans_ErrorLookup"
266                MOV     PC,R10
267.keywordtable
268.szedstatus    := "EdStatus"+bl$:FNalign
269                & edstatus
270                & &20000000 ; help printed by code
271                & syntax0args
272                & edstatushelp
273.szerasehistory:= "EraseHistory"+bl$:FNalign
274                & erasehistory
275                & &20000000 ; help printed by code
276                & syntax0args
277                & erasehisthelp
278.szrecall      := "Recall"+bl$:FNalign
279                & recall
280                & &20000000 ; help printed by code
281                & syntax0args
282                & recallhelp
283.szloadhist    := "LoadHistory"+bl$:FNalign
284                & loadhistory
285                & &20010001 ; help printed by code
286; Maybe we want to GSTrans it?
287;               & &20010101 ; help printed by code
288                & syntax1fnm
289                & loadhisthelp
290.szsavehist    := "SaveHistory"+bl$:FNalign
291                & savehistory
292                & &20010001 ; help printed by code
293                & syntax1fnm
294                & savehisthelp
295;                = "Editor"+bl$
296;                FNalign
297;                & 0
298;                & &20000000 ; help printed by code
299;                & 0
300;                & editorhelp
301                & 0
302.swihandler     LDR     R12,[R12]
303                CMP     R11,#(swijmptabend-swijmptab)/4
304                ADDLO   PC,PC,R11,LSL#2
305                B       ukswi
306.swijmptab      B       le_setopts
307                B       le_getopts
308                B       CreateBuffer
309                B       DeleteBuffer
310                B       SetPos
311                B       GetPos
312                B       GetLine
313                B       AppendLine
314                B       DeleteLine
315                B       ReadInfo
316                B       ReadLine
317]
318IF debug% THEN
319[OPTA%
320                B       X
321]
322ENDIF
323[OPTA%
324.swijmptabend
325; /E
326; R0 = buffer size (0 for default)
327; R1 = flags
328; R2 = min len to record (0=>no min)
329; R3 = max len to record (0=>no max)
330; R4 = cursors
331.le_setopts     TEQ     R0,#0
332                MOVEQ   R0,#dfltsize
333                TEQ     R2,#0
334                MOVEQ   R2,#1
335                TEQ     R3,#0
336                MOVEQ   R3,#1<<30 ; was (1<<31)-1
337                STMIB   R12,{R0-R4}          ; Store values (no writeback)
338                MOV     PC,R14
339; /X
340; R0 = buffer size
341; R1 = flags
342; R2 = min len to record
343; R3 = max len to record
344; R4 = cursors
345.le_getopts     LDMIB   R12,{R0-R4}          ; Load values (no writeback)
346                MOV     PC,R14
347; /E R0=size (0 for default)
348;    R1=0 (for expansion, later used to point to more info)
349; or to pass a taskhandle -
350;    R0=size (0 for default)
351;    R1=taskhandle to tie buffer to for autodelete (-1 for none)
352;    R2=0 (for expansion, later used to point to more info)
353;
354; (optionally min and max length to buffer, flags)
355; /X R0=handle or 0 for can't create (0 won't be returned as a valid handle,
356;               so may be used to flag "no handle" in your code)
357; Returns error if can't create (due to lack of memory probably)
358.CreateBuffer   MOV     R10,R1
359                MOV     R11,R14
360]
361IF countclientbuf% THEN
362[OPTA%
363                LDR     R14,[R12,#clbufcnt]
364                ADD     R14,R14,#1
365                STR     R14,[R12,#clbufcnt]
366]
367ENDIF
368[OPTA%
369                MOV     R1,R0
370                MVN     R0,#NOT(-1)
371                BL      newinst
372                MOV     R1,R10
373                TEQ     R0,#0
374                LDRNE   R10,[R0,#buf]
375                STRNE   R10,[R0,#cur]     ; Set cur pointer to top of buffer
376                STRNE   R1,[R0,#cltaskh]
377                MOVNE   PC,R11
378                MOV     R14,R11
379                B       noroomerror
380; /E R0=handle
381.DeleteBuffer   STMFD   sp !,{R14}
382                ADD     R10,R12,#morebufs-next ; Nasty, eh?
383.DBlp           MOV     R11,R10
384                LDR     R10,[R11,#next]
385                TEQ     R10,#0
386                BEQ     DBbad
387                TEQ     R10,R0
388                BNE     DBlp
389                LDR     R14,[R0,#next]    ; R0 points to instance to kill
390                STR     R14,[R11,#next]   ; Unlink instance
391                BL      freeinstance
392                LDMFD   sp !,{PC}
393.DBbad          BL      invalid_id
394                LDMFD   sp !,{PC}
395; /E R0=handle, R1=line no. (use R1=&7fffffff for end)
396; -ve R1 means from end of buffer
397; R1 = &80000001 for prev line
398; R1 = &80000002 for next line
399; R1 = &80000000 for prev line (wrap)
400; R1 = &80000003 for next line (wrap)
401.SetPos         STMFD   sp !,{R9,R14}
402                MOV     R9,R0
403                BL      validate_id
404                LDMFD   sp !,{R9,R14}
405                MOVVS   PC,R14
406                BIC     R10,R1,#3
407                TEQ     R10,#&80000000
408                LDMIA   R0,{R10,R11,R12}  ; cur, buf, end
409                ADDEQ   PC,PC,r1,LSL#2    ; MSB is lost...
410                B       foo
411                B       SetPos_decwr      ; Special case for prev line (wrap)
412                B       SetPos_dec        ; Special case for prev line
413                B       SetPos_inc        ; Special case for next line
414                B       SetPos_incwr      ; Special case for next line (wrap)
415.foo            CMN     R1,#-&7fffffff    ; Special case to save scanning
416                BEQ     SetPos_end        ; whole buffer to find end
417                MOVS    R10,R1
418                BMI     SetPosneg
419                ADD     R10,R1,#1
420.SetPoslp
421.SetPoslp2      LDRB    R12,[R11],#1
422                CMP     R12,#13
423                BGT     SetPoslp2         ; Skip a line
424                SUBLT   R11,R11,#1
425                BLT     SetPosDone
426                SUBS    R10,R10,#1        ; EQ means zero means end of buffer
427                BNE     SetPoslp          ; Otherwise decrement count
428.SetPosDone     STR     R11,[R0,#cur]     ; And set cur
429                MOV     PC,R14
430;
431.SetPosneg      STMFD   sp !,{r14}
432                SUB     R12,R12,#1
433.SetPosneglp    CMP     R12,R11           ; Check not start of buf
434                BEQ     SetPosnegDone
435.SetPosneglp2   LDRB    R14,[R12,#-1]!
436                CMP     R14,#13
437                BGT     SetPosneglp2      ; Skip a line
438                ADDS    R10,R10,#1        ; EQ means zero means end of buffer
439                BNE     SetPosneglp       ; Otherwise decrement count
440                ADD     R12,R12,#1
441.SetPosnegDone  STR     R12,[R0,#cur]     ; And set cur
442                LDMFD   sp !,{PC}
443;
444; Set current position to end of buffer
445.SetPos_end     SUB     R12,R12,#1
446                STR     R12,[R0,#cur]     ; cur = end-1
447                MOV     PC,R14
448;
449.SetPos_decwr   SUB     R10,R10,#1
450                CMP     R10,R11           ; Check if already at start of buf
451                SUBLS   R10,R12,#1        ; and wrap if we are
452                STRLS   R10,[R0,#cur]     ; And set cur
453                MOVLS   PC,R14
454                ADD     R10,R10,#1
455;
456.SetPos_dec     SUB     R10,R10,#1        ; Check not already at start of buf
457                CMP     R10,R11           ; If empty LO - EQ otherwise
458                MOVLS   PC,R14
459.SetPos_declp   LDRB    R12,[R10,#-1]!
460                CMP     R12,#13
461                BGT     SetPos_declp      ; Skip a line backwards
462                ADD     R10,R10,#1
463                STR     R10,[R0,#cur]     ; And set cur
464                MOV     PC,R14
465;
466.SetPos_incwr   LDRB    R12,[R11]         ; Look at first byte
467                TEQ     R12,#0            ; Give up if buffer empty
468                MOVEQ   PC,R14
469                LDRB    R12,[R10],#1
470                TEQ     R12,#0
471                ADDEQ   R10,R11,#1
472                STREQ   R10,[R0,#cur]     ; And set cur
473                MOVEQ   PC,R14
474;
475.SetPos_inc
476.SetPos_inclp   LDRB    R12,[R10],#1
477                CMP     R12,#13
478                BGT     SetPos_inclp      ; Skip a line
479                SUBLT   R10,R10,#1
480                STR     R10,[R0,#cur]     ; And set cur
481                MOV     PC,R14
482]
483IF debug% THEN
484[OPTA%
485; Do a recall on this buffer
486.X              MOV     R11,R14
487                MOV     R10,R9
488                MOV     R9,R0
489                BL      recallbuffer
490                MOV     R9,R10
491                MOV     PC,R11
492]
493ENDIF
494[OPTA%
495; /E R0=handle
496; /X R1=line no.
497.GetPos         STMFD   sp !,{R9,R14}
498                MOV     R9,R0
499                BL      validate_id
500                LDMFD   sp !,{R9,R14}
501                MOVVS   PC,R14
502                MOV     R1,#0
503                LDR     R12,[R0,#cur]
504                LDR     R11,[R0,#buf]
505                ADD     R11,R11,#1
506                CMP     R11,R12
507                MOVHS   PC,R14            ; Top of buffer - line 0
508.GetPoslp
509.GetPoslp2      LDRB    R10,[R11],#1
510                CMP     R10,#32
511                BGE     GetPoslp2         ; Skip a line
512                ADD     R1,R1,#1          ; Increase count
513                CMP     R11,R12
514                BLO     GetPoslp          ; Loop if not there yet
515                MOV     PC,R14
516; /E R0=handle, R1->buffer, R2=buffer len
517; /X R2=actual length
518.GetLine        STMFD   sp !,{R9,R14}
519                MOV     R9,R0
520                BL      validate_id
521                LDMFD   sp !,{R9,R14}
522                MOVVS   PC,R14
523                LDR     R11,[R0,#cur]
524                MOV     R12,R1
525.GetLinelp      SUBS    R2,R2,#1
526                LDRGEB  R10,[R11],#1
527                STRGEB  R10,[R12],#1
528                CMPGE   R10,#32
529                BGE     GetLinelp
530                MOV     R2,#0
531                STRB    R2,[R12,#-1]
532                CMP     R10,#32
533.GetLinelp2     LDRGEB  R10,[R11],#1
534                CMPGE   R10,#32
535                BGE     GetLinelp2
536                LDR     R12,[R0,#cur]
537                SUB     R2,R11,R12
538                SUB     R2,R2,#1          ; Return actual length
539                MOV     PC,R14
540; /E R0=handle, R1->line (ctrl terminated)
541.AppendLine     STMFD   sp !,{R6,R7,R9,R14}
542                MOV     R9,R0             ; Fake up variables
543                BL      validate_id
544                MOVVC   R7,R1
545                MOVVC   R6,#0
546                BLVC    addnewhist
547                LDMFD   sp !,{R6,R7,R9,PC}
548; /E R0=handle
549.DeleteLine     STMFD   sp !,{R9,R14}
550                MOV     R9,R0             ; Fake up variables
551                BL      validate_id
552                LDRVC   R0,[R9,#cur]
553                BLVC    delhistent
554                LDMFD   sp !,{R9,PC}
555; /E R0=task handle to read info for
556; /X R0=length of line (or -1 for inactive ; -2 for taskwindow never seen)
557;    R1=cursor posn in line
558.ReadInfo       STMFD   sp !,{R2,R14}
559;BL showregs
560                SUB     R1,R12,#next-head ; Nasty, eh?
561.richeckinstlp                            ; Check R0 against taskh of
562                LDR     R1,[R1,#next]     ; each instance
563                TEQ     R1,#0
564                BEQ     richeckinstskip   ; Not one of my taskwindows
565                LDR     R14,[R1,#taskh]
566                TEQ     R0,R14
567                BNE     richeckinstlp
568                LDR     R0,[R1,#r7]
569                TEQ     R0,#0
570                MVNEQ   R0,#NOT(-1)
571                LDMEQFD sp !,{R2,PC}
572;BL showregs
573                SUB     R2,R0,#1
574.ristrlenlp     LDRB    R14,[R2,#1]!
575                CMP     R14,#32
576                BGE     ristrlenlp
577;BL showregs
578                SUB     R0,R2,R0
579                LDR     R1,[R1,#r6]
580                LDMFD   sp !,{R2,PC}
581; not a valid task handle
582.richeckinstskip
583                MVN     R0,#NOT(-2)
584                LDMFD   sp !,{R2,PC}
585; /E R9=buffer ID
586; /X Error if invalid
587.validate_id    STMFD   sp !,{R14}
588                ADD     R14,R12,#morebufs-next ; Nasty, eh?
589._              LDR     R14,[R14,#next]
590                CMP     R14,R9
591                LDMEQFD sp !,{PC}
592                TEQ     R14,#0
593                BNE     _
594                LDMFD   sp !,{R14}        ; fall through
595.invalid_id     STMFD   sp !,{R14}
596                ADR     R0,invalid_id_msg
597                SWI     "XOS_GenerateError"
598                LDMFD   sp !,{PC}
599.invalid_id_msg & swichunk
600                = "Invalid history buffer ID"+bl$
601                FNalign
602; /E R1 = Free value, R2 = Total value
603.docolumns      STMFD   sp !,{R0-R2,R14}
604                SUB     R0,R2,R1          ; Used value
605                MOV     R1,#8             ; Field width
606                BL      outpadval
607                SUB     R0,R2,R0          ; Free value (r1 on entry)
608                BL      outpadval
609                MOV     R0,R2             ; Total value
610                BL      outpadval
611                SWI     XOS_NewLine
612                LDMFD   sp !,{R0-R2,PC}
613;!HACK! problem with this code is that it process each buffer once per client
614; dereference r12
615;                LDR     R3,[R12,#head]
616;                TEQ     R3,#0
617;                LDMEQFD sp !,{R0-R3,PC}^
618;                BL      readedsize
619;                MOV     R0,R0,ASL#10      ; Convert to K
620;.edsizefiddlelp LDR     R1,[R3,#buf]
621;                ADD     R2,R1,R0
622;                STR     R2,[R3,#limit]
623;                LDR     R14,[R3,#end]
624;                SUBS    R14,R14,R2
625;                BLE     edsizefiddleok    ; Contents still fits
626;                ADD     R2,R1,R14
627;.edsizefiddllp2 LDRB    R14,[R2],#1
628;                CMP     R14,#13
629;                BGT     edsizefiddllp2
630;                SUB     R2,R2,#1
631;                LDR     R14,[R3,#cur]
632;                ADD     R14,R14,R2
633;                SUBS    R14,R14,R1        ; Adjust cur
634;;!HACK! next line broken for top-bit-set addresses
635;                STRPL   R14,[R3,#cur]     ; cur is decreased, so 0,-1 <=> MI
636;.edsizefiddllp3 LDRB    R14,[R2],#1
637;                STRB    R14,[R1],#1
638;                TEQ     R14,#0
639;                BNE     edsizefiddllp3
640;.edsizefiddleok LDR     R3,[R3,#next]
641;                TEQ     R3,#0
642;                BNE     edsizefiddlelp
643;               LDMFD   sp !,{R0-R3,PC}^
644; Module initialisation
645.init           STMFD   sp !,{R10,R14}
646                MOV     r0,r10
647                BL      start
648                STMFD   sp !,{R0-R4}
649                MOV     R5,R12
650                LDR     R12,[R12]
651                BL      alloc_init        ; Attempt to set up a dynamic area
652                BL      claimspace
653                ADDVS   sp,sp,#20
654                LDMVSFD sp !,{R10,PC}
655                BL      claimreadlinev
656                BVS     initfail
657                BL      findkmod ; for command completion
658                MOV     R0,#1
659                SWI     "XOS_InstallKeyHandler"
660                CMP     R0,#1
661                MOVNE   R0,#2
662                STR     R0,[R12,#kbdtype]
663                LDMIA   sp !,{r0-r4}
664                BL      le_setopts
665                LDMFD   sp !,{R10,PC}
666.initfail       STR     R0,[sp,#16]! ; ADD sp,sp,#20;STMFD sp!,{R0}
667                MOV     R10,#1
668                BL      finalise
669                LDMFD   sp !,{R0}
670                SWI     "XOS_GenerateError"
671                LDMFD   sp !,{R10,PC}
672; /E R0 -> command line (*NOT* incl. modulename?)
673.start          STMFD   sp !,{r0-r4,r14}
674                MOV     r1,#0
675                MOV     r2,#0
676                MOV     r3,#0
677                MOV     r4,#0
678                MOV     r14,#&100 ;ins flash/under; over flash/block
679                STMIA   sp,{r1-r4,r14}
680                SUB     R1,R0,#1
681.startlp        LDRB    R2,[R1,#1]!
682                CMP     R2,#32
683                BEQ     startlp
684                LDMLTFD sp !,{r0-r4,pc}
685                MOV     R0,#1<<31          ; Check terminated by spc or ctrl
686                SWI     "XOS_ReadUnsigned"
687                STRVC   r2,[sp]
688                SWIVC   "XOS_ReadUnsigned"
689                STRVC   r2,[sp,#4]
690                SWIVC   "XOS_ReadUnsigned"
691                STRVC   r2,[sp,#8]
692                SWIVC   "XOS_ReadUnsigned"
693                STRVC   r2,[sp,#12]
694                SWIVC   "XOS_ReadUnsigned"
695                STRVC   r2,[sp,#16]
696                LDMFD   sp !,{r0-r4,pc}
697; Free buffers of instance and then instance block itself
698; NB note down the next pointer *before calling* this routine!
699; /E R0->instance ; HACKHACKHACK
700.freeinstance   STMFD   sp !,{R0-R1,R14}
701                MOV     R1,R0
702                LDR     R0,[R1,#fkeybuf]
703                BL      free              ; Free fkey buffer (if any)
704                LDR     R0,[R1,#yankbuf]
705                BL      free              ; Free yank buffer (if any)
706                LDR     R14,[R1,#taskh]
707                CMN     R14,#-(-1)        ; Client buffer, so *do* free
708]
709IF countclientbuf% THEN
710[OPTA%
711                LDREQ   R14,[R12,#clbufcnt]
712                SUBEQ   R14,R14,#1
713                STREQ   R14,[R12,#clbufcnt]
714]
715ENDIF
716[OPTA%
717                LDRNE   R14,[R12,#flags]
718                EORNE   R14,R14,#f_LocalHist ; !HACK! !HACK! !HACK!
719                TSTNE   R14,#f_LocalHist  ; NE => Global history
720                LDRNE   R14,[R12,#head]
721                TEQNE   R14,#0            ; NE => Global history & more inst
722                LDREQ   R0,[R1,#buf]
723                BLEQ    free
724                MOV     R0,R1
725                BL      free              ; Free instance
726                LDMFD   sp !,{R0-R1,PC}
727; Module finalisation - relase workspace & vector and restore cursor
728; /E R10 = 0 => non-fatal, 1 => fatal, R12 -> priv word, sp(R13) -> SVC stack
729; /X May corrupt R0-R6, R12, R14, flags
730.finalise       MOV     R6,R14
731                MOV     R5,R12
732                LDR     R12,[R12]
733                TEQ     R10,#0
734                BEQ     finalnonfatal
735                LDR     R14,[R12,#morebufs]
736                TEQ     R14,#0            ; Refuse to die if my clients
737                BNE     dontdie           ; still need me
738]
739IF countclientbuf% THEN
740[OPTA%
741                LDR     R14,[R12,#clbufcnt]
742                TEQ     R14,#0
743                BNE     dontdie
744]
745ENDIF
746[OPTA%
747                LDR     R0,[R12,#head]    ; Fatal finalisation
748                MOVS    R2,R0
749                BEQ     freechainend      ; If no instances!
750; !HACK! (not really) (cur==0)
751.checkchainlp   LDR     R14,[R2,#cur]     ; Check - no active instances?
752                TEQ     R14,#0
753                BNE     dontdie
754                LDR     R2,[R2,#next]
755                TEQ     R2,#0
756                BNE     checkchainlp
757.freechainlp    LDR     R2,[R0,#next]
758                STR     R2,[R12,#head]    ; Unlink next instance
759                BL      freeinstance
760                MOVS    R0,R2
761                BNE     freechainlp
762.freechainend   MOV     R0,R12            ; R12 = [privword]
763                BL      free              ; Free all workspace
764                STR     R0,[R5]           ; R5 = R12 on entry
765                BL      alloc_final
766.finalnonfatal  BL      relreadlinev
767;                MOV     R0,#%00           ; Reset cursor shape
768;                BL      setcursorshape
769                MOV     PC,R6
770;
771.dontdie        ADR     R0,dontdiemsg
772                SWI     "XOS_GenerateError"
773                MOV     PC,R6
774;
775.dontdiemsg     & 0
776                = prog$+" in use"+bl$
777                FNalign
778.freetaskh      STMFD   R13!,{R0,R2-R3,R14}
779                LDR     R2,[R12,#head]
780                SUB     R3,R12,#next-head
781.freethchainlp  MOVS    R0,R2             ; End of list?
782                LDMEQFD sp !,{R0,R2-R3,PC}
783                LDR     R2,[R0,#next]
784                LDR     R14,[R0,#taskh]
785                TEQ     R14,#0            ; Don't free the command line one
786                MOVEQ   R3,R0
787                STRNE   R2,[R3,#next]     ; If taskwindow, unlink instance
788                BLNE    freeinstance      ; and free it
789                B       freethchainlp
790.servicetable   & 0                 ; RO4-format service call table
791                & serviceaccept
792                & &27               ; Service_Reset
793                & &53               ; Service_WimpCloseDown
794                & 0
795                & servicetable
796; /E R1 = Service call number
797.servicecall    MOV     R0,R0
798                TEQ     R1,#&53           ; Service_WimpCloseDown
799                TEQNE   R1,#&27           ; Service_Reset
800                MOVNE   PC,R14
801.serviceaccept  STMFD   sp !,{R0-R1,R5,R14}
802                MOV     R5,R12
803                LDR     R12,[R12]
804                TEQ     R1,#&53           ; Service_WimpCloseDown
805                BEQ     service_wimpclosedown
806                TEQ     R12,#0            ; Must be Service_Reset
807                BEQ     serviceaccept_claimspace
808                BL      freetaskh
809                BL      claimreadlinev
810                LDMFD   sp !,{R0-R1,R5,PC}
811.serviceaccept_claimspace
812                BL      claimspace
813                BL      claimreadlinev
814                LDMFD   sp !,{R0-R1,R5,PC}
815                ;
816.service_wimpclosedown
817; /E R0=0 for Wimp_CloseDown, >0 for Wimp_Init. in domain, R2 = taskhandle
818; NB if R0<>0, then Wimp_Init may get blocked (eg *StartTask in taskwindow)
819; (Is this right? I think Taskwindow should block Wimp_Init... !HACK!)
820                TEQ     R0,#0
821                LDMNEFD sp !,{R0-R1,R5,PC}
822                SUB     R0,R12,#next-head ; Nasty, eh?
823.checkinstlp    MOV     R1,R0             ; Check R2 against taskh of
824                LDR     R0,[R1,#next]     ; each instance
825                TEQ     R0,#0
826                BEQ     checkinstskip     ; Not one of my taskwindows
827                LDR     R14,[R0,#taskh]
828                TEQ     R2,R14
829                BNE     checkinstlp
830                LDR     R14,[R0,#next]    ; R0 now points to instance to kill
831                STR     R14,[R1,#next]    ; Unlink instance
832                BL      freeinstance
833                ;                         ; Now check client buffers
834.checkinstskip  ADD     R0,R12,#morebufs-next ; Nasty, eh?
835.checkinstlp2   MOV     R1,R0             ; Check R2 against taskhandle of
836.checkinstmore  LDR     R0,[R1,#next]     ; each client
837                TEQ     R0,#0
838                LDMEQFD sp !,{R0-R1,R5,PC} ; Nope
839                LDR     R14,[R0,#cltaskh]
840                TEQ     R2,R14
841                BNE     checkinstlp2
842                LDR     R14,[R0,#next]    ; R0 now points to instance to kill
843                STR     R14,[R1,#next]    ; Unlink instance
844                BL      freeinstance
845                B       checkinstmore     ; Keep going in case there's more
846; /E R0 = char
847.writec         STMFD   sp !,{R14}
848                TST     R8,#fPasswd
849                LDRNE   R0,[R9,#pchar]
850                SWI     XOS_WriteC
851                LDMFD   sp !,{pc}
852; /E R0 -> history entry
853; Contents of linebuffer are cleared, history entry is copied into
854; linebuffer, redisplayed and the cursor put at the end
855.fetchhist      STMFD   sp !,{R0,R1,R14}
856                STR     R0,[R9,#cur]      ; Set current history pointer
857                BL      clearline
858                MOV     R6,#0
859                MOV     R1,R0
860.fetchhistlp    TEQ     R6,R10            ; Truncate if recalled line
861                LDRNEB  R0,[R1],#1        ; would overfill buffer
862                TEQNE   R0,#0             ; and change zero to CR
863                MOVEQ   R0,#13
864                STRB    R0,[R7,R6]
865                TEQ     R0,#13
866                ADDNE   R6,R6,#1
867                LDMEQFD sp !,{R0-R1,PC}
868                BL      writec
869                B       fetchhistlp
870.updatecursor   STMFD   sp !,{R0,R14}
871                LDR     R0,[R12,#cursors]
872                TST     r8,#fOver%
873                MOVNE   R0,R0,LSR #8
874                AND     R0,R0,#3
875                BL      setcursorshape
876                LDMFD   sp !,{R0,PC}
877; Erase entire line and leave cursor at start
878; /X R6 = 0, R11 = 0, modified flag cleared
879.clearline      STMFD   sp !,{R0,R14}
880                BL      gotoend
881.clearlinelp    BL      del
882                BNE     clearlinelp
883                MOV     R11,#0            ; Put mark at start too
884                MOV     R14,#13
885                STRB    R14,[R7]
886                BIC     r8,r8,#fEdit%     ; Clear modified flag
887                LDMFD   sp !,{R0,PC}
888; Load R0 with character at current cursor position and
889; check if it is a character marking a break between words
890; /X R0 = char, Eq => break, Gt => non-break char, Lt => End of line
891.ldrr0testbreak LDRB    R0,[R7,R6]
892;
893; Check if R0 is a character marking a break between words
894; /E R0 = char; /X Eq => break, Gt => non-break char, Lt => End of line
895.testbreak      CMP     R0,#ASC" "
896                TEQGT   R0,#ASC"("
897                TEQGT   R0,#ASC")"
898                MOV     PC,R14
899; /E R7->linebuffer
900;    R8=(minchar<<24)+maxchar+flags in bits 8-23 (only fCopy% on entry)
901;    R9->current instance pointer
902;    R10=maxlength
903; Additionally, in routine
904;    R6=current cursor posn
905;    R11=position of mark
906;    R5 is unused
907; /X R6=length of line, R8 contains updated flags
908.dolineedit     STMFD   sp !,{R0-R4,R11,R14}
909                BIC     r8,r8,#(fAll%ANDNOTfCopy%); clear all flgs bar fCopy
910                LDR     R14,[R12,#flags]  ; Set fOver if overtype mode on
911                TST     R14,#f_DfltOver   ; by default
912                ORRNE   r8,r8,#fOver%
913                MVN     R14,#NOT(-1)      ; Set current ptr for this instance
914                STR     R14,[r9,#cur]     ; to the bottom
915                STR     R14,[R9,#match]   ; No page-up active
916                TEQ     R4,#0
917                MOVEQ   R4,#256           ; null printout if password bit set
918                CMP     R4,#127
919                CMPNE   R4,#32
920                MOVLS   R4,#ASC"-"
921                STR     R4,[R9,#pchar]
922                BL      updatecursor      ; Sort out cursor shape
923                MOV     R6,#0             ; Current cursor posn
924                STR     R6,[R9,#compcontext]; Not completing filename
925                BL      free_cmdtree      ; Or command
926                MOV     R11,#0            ; Current mark posn
927                MOV     R0,#13            ; Buffer empty initially
928                STRB    R0,[R7]
929.nextchar       BIC     R8,R8,#fShowComp OR fCompRev OR fTcsh
930                LDR     R1,[R9,#fkeybuf]  ; Are we in the middle of expanding
931                TEQ     R1,#0             ; a function key?
932                BNE     fnkeyexpand
933                STR     R6,[R9,#r6]
934                STR     R7,[R9,#r7]
935                MOV     R0,#216
936                MOV     R1,#0
937                MOV     R2,#&FF           ; See if the OS is doing an Fkey
938                SWI     XOS_Byte          ; expansion and if so, don't try
939                SWI     XOS_ReadC         ; and work out a Zap keycode
940                BCS     badreadc
941                TEQ     R1,#0
942                BNE     vanilla
943                MOV     R4,R0
944                MOV     R0,#198
945                MOV     R1,#0
946                MOV     R2,#&FF           ; See if the OS is reading from a
947                SWI     XOS_Byte          ; *Exec file and if so, don't try
948                TEQ     R1,#0             ; and work out a Zap keycode
949                MOV     R0,R4             ; NB for some reason this test
950                BNE     vanilla           ; doesn't work in a TaskWindow (on
951;                MOV     R4,R0            ; a Risc PC anyway)
952                BL      checkmodkeys
953                MOVEQ   R3,#%1000         ; lowest 4 bits are ~s~csc
954                MOVNE   R3,#%0010
955                ORRCC   R3,R3,#%0100
956                ORRCS   R3,R3,#%0001
957                MOV     R0,#122
958                SWI     XOS_Byte          ; /X R1 = intl. key # or &FF
959                MOVS    R0,R4             ; Extended key code ?
960                BEQ     extended
961                CMP     R0,#32
962                BGT     gt32
963                TSTEQ   R3,#%0100
964                MOVEQ   R0,#0             ; cSpace -> &000
965                BEQ     doshift           ; scSpace -> &100
966                TEQ     R1,#47            ; '<-|'
967                MOVEQ   R0,#&1C
968                CMP     R0,#10
969                BGE     gt9
970.le9            ADR     R14,ntab
971                LDRB    R14,[R14,R0]
972                TEQ     R14,R1
973                ADDEQ   R0,R0,#&100+ASC"0"
974                BEQ     widget
975.gt9            CMP     R0,#13
976                BEQ     cr
977                CMP     R0,#27
978                BLT     skippy
979                LDR     R14,[R12,#kbdtype]
980                TEQ     R14,#1
981                ADREQ   R14,ctab_arc-27
982                ADRNE   R14,ctab_rpc-27
983                LDRB    R14,[R14,R0]
984                TEQ     R14,R1
985                BNE     skippy
986.unskippy       TEQ     R0,#30
987                ADDNE   R0,R0,#&2B-27
988                MOVEQ   R0,#&36
989.skippy         TEQ     R0,#0             ; &132 is Zap code for c2 (ctrl @)
990                MOVEQ   R0,#&32           ; NB c0 returns &00 too
991.backin         CMP     R0,#32            ; Orr &100 if >32
992                BGT     orrinstr
993.doshift        TST     R3,#2             ; Orr &100 if Shifted
994                BEQ     decoded
995.orrinstr       ORR     R0,R0,#&100
996                CMP     R0,#&120
997                RSBGTS  R14,R0,#&140
998                BLE     decoded
999.widget         TST     R3,#2
1000                ADDNE   R0,R0,#&020
1001                B       decoded
1002.cr             TEQ     R1,#73            ; 'Return'
1003                MOVEQ   R0,#&1D
1004                TEQ     R1,#60            ; 'kEnter'
1005                BNE     doshift
1006                MOV     R2,#&66
1007                B       kpadenter
1008.stab          := 91 ; k*
1009                = 58 ; k+
1010                =  0 ; dummy to allow for ,
1011                = 59 ; k-
1012                = 76 ; k.
1013                = 74 ; k/
1014.stab2         := &62
1015                = &65
1016                = 0
1017                = &64
1018                = &67
1019                = &61
1020FNalign
1021.kpadsym
1022                ADR     R2,stab2-42
1023                SUB     R14,R2,#stab2-stab
1024                LDRB    R14,[R14,R0]
1025                LDRB    R2,[R2,R0]
1026.kpadnotnum     TEQ     R14,R1
1027                BNE     decoded
1028.kpadenter      ADD     R0,R2,#&100
1029                TEQ     R3,#%1001         ; c
1030                SUBEQ   R0,R0,#&040
1031                TEQ     R3,#%0110         ; s
1032                ADDEQ   R0,R0,#&010
1033                TEQ     R3,#%0011         ; sc
1034                SUBEQ   R0,R0,#&020
1035                B       decoded
1036.deletekey      TST     R3,#1             ; Ctrl-Delete
1037                MOVNE   R0,#&1F
1038                B       doshift
1039.gt32           CMP     R0,#&7F
1040                BEQ     deletekey
1041                TEQ     R0,#ASC","
1042                BEQ     decoded
1043                TEQ     R0,#ASC"#"
1044                MOVEQ   R14,#90
1045                MOVEQ   R2,#&63
1046                BEQ     kpadnotnum
1047                CMP     R0,#42            ; "*"
1048                RSBGES  R14,R0,#47        ; "/"
1049                BGE     kpadsym
1050.number         CMP     R0,#ASC"0"
1051                RSBGES  R14,R0,#ASC"9"
1052                BLT     notdigit
1053                ADR     R14,ktab-ASC"0"
1054                LDRB    R14,[R14,R0]
1055                TEQ     R14,R1
1056                BEQ     kpadnum
1057                LDR     R14,[R12,#osver]
1058                CMP     R14,#&A3          ; What does 3.00 do? !HACK!
1059                BGE     notdigit
1060                TST     R3,#1             ; Catch RISC OS 2 Ctrl-<digit>
1061                ADDNE   R0,R0,#&130-ASC"0"
1062                TSTNE   R3,#%10           ; Shift? !HACK! Test me!
1063                ADDNE   R0,R0,#&20
1064                B       notdigit
1065;
1066.kpadnum        ADD     R0,R0,#&1C0-ASC"0"
1067                TST     R3,#1
1068                ADDNE   R0,R0,#&20        ; Add &20 for control
1069                TST     R3,#%10
1070                ADDNE   R0,R0,#&10        ; Add &10 for shift
1071.notdigit       TEQ     R1,#89            ; 'Delete'
1072                MOVEQ   R0,#&1C
1073                BNE     decoded
1074                TST     R3,#1
1075                MOVNE   R0,#&1F
1076                TSTNE   R3,#3
1077                MOVNE   R0,#&7F
1078                B       decoded
1079.ntab          :=  39 ; 0
1080                =  48 ; 1
1081                =  49 ; 2
1082                =  17 ; 3
1083                =  18 ; 4
1084                =  19 ; 5
1085                =  52 ; 6
1086                =  36 ; 7
1087                =  21 ; 8
1088                =  38 ; 9
1089.ktab          := 106 ; k0
1090                = 107 ; k1
1091                = 124 ; k2
1092                = 108 ; k3
1093                = 122 ; k4
1094                = 123 ; k5
1095                =  26 ; k6
1096                =  27 ; k7
1097                =  42 ; k8
1098                =  43 ; k9
1099= "PAD" ; so ctab-27 is a multiple of four!
1100.ctab_arc      :=  56 ; '['
1101                = 120 ; '\'
1102                =  88 ; ']'
1103                =  24 ; '^'
1104                =  23 ; '_'
1105= "PAD" ; so ctab-27 is a multiple of four!
1106.ctab_rpc      :=  56 ; '['
1107                =  94 ; '\'
1108                =  88 ; ']'
1109                =  24 ; '^'
1110                =  23 ; '_'
1111                FNalign
1112.extended
1113                SWI     XOS_ReadC
1114                BCS     badreadc
1115                MOVS    R4,R0
1116                BEQ     le9
1117                ORR     R0,R0,#&100
1118                BIC     R14,R0,#&130
1119                TEQ     R14,#&8E
1120                TEQEQ   R1,#78
1121                EOREQ   R0,R0,#&50        ; Page Down
1122                TEQ     R14,#&8F
1123                TEQEQ   R1,#63
1124                EOREQ   R0,R0,#&50        ; Page Up
1125                BIC     R14,R0,#&30
1126                SUB     R14,R14,#&1C0
1127                CMP     R14,#2            ; Logo or Menu keys?
1128                BHS     decoded           ; ... no
1129                TST     R0,#&10           ; convert to internal key number
1130                ORRNE   R0,R0,#4
1131                TST     R0,#&20
1132                BIC     R0,R0,#&F0
1133                ORRNE   R0,R0,#&10
1134                ORR     R0,R0,#&68
1135                TEQ     R1,#126           ; Is it the right-hand Logo key?
1136                ADDEQ   R0,R0,#2          ; If so, tweak the key code
1137.decoded
1138;BL outhex
1139;SWI XOS_NewLine
1140;;MOV R0,R4
1141                FNADRL(14,jmptab)
1142                LDRB    R1,[R14,R0]
1143                MOV     R0,R4             ; For vanilla, etc
1144                ADR     R14,nextchar      ; Setup return address in SVC mode
1145;               ORR     R14,R14,#%11
1146                ADD     PC,PC,R1,ASL#2
1147.keyvar        := "key$"            ; Padding word needed anyway
1148.base
1149.fileropen      TST     R8,#fPasswd
1150                BEQ     canon
1151                MOV     PC,R14
1152; /X EQ iff already at start of line
1153.left           TST     R8,#fPasswd
1154                MOVNE   PC,R14
1155                STMFD   sp !,{R14}
1156                TEQ     R6,#0             ; At start of line ?
1157                BLNE     _left            ; If not, move cursor left
1158                LDMFD   sp !,{PC}
1159; /X EQ iff already at end of line
1160.right          TST     R8,#fPasswd
1161                MOVNE   PC,R14
1162                STMFD   sp !,{R0,R14}
1163                LDRB    R0,[R7,R6]
1164                TEQ     R0,#13            ; At end of line ?
1165                BLNE    _right            ; If not, move cursor right
1166                LDMFD   sp !,{R0,PC}
1167; Move cursor to the end of the line
1168; /X R6 = length of line
1169.cright
1170.gotoend        TST     R8,#fPasswd
1171                MOVNE   PC,R14
1172                STMFD   sp !,{R14}
1173.gotoendlp      BL      right             ; Returns EQ iff already at end
1174                BNE     gotoendlp
1175                LDMFD   sp !,{PC}
1176; Move cursor to start of the line
1177; /X R6 = 0
1178.cleft
1179.gotostart      TST     R8,#fPasswd
1180                MOVNE   PC,R14
1181                STMFD   sp !,{R14}
1182.gotostartlp    BL      left
1183                BNE     gotostartlp
1184                LDMFD   sp !,{PC}
1185; Goto to the start of the next word (spaces separate words)
1186; /X R6 changed
1187.sright
1188.nextword       TST     R8,#fPasswd
1189                MOVNE   PC,R14
1190                STMFD   sp !,{R0,R14}
1191.nextwordlp     BL      ldrr0testbreak    ; Find first break to the right
1192                BLLE    nextwordlp2
1193                BL      _right
1194                B       nextwordlp
1195.nextwordlp2    BLEQ    ldrr0testbreak    ; Find first non-space to right
1196                LDMNEFD sp !,{R0,PC}
1197                BL      _right            ; or end of line
1198                B       nextwordlp2
1199; Goto to the space after end of the previous word (spaces separate words)
1200; /X R6 changed
1201.sleft
1202.prevword       TST     R8,#fPasswd
1203                MOVNE   PC,R14
1204                STMFD   sp !,{R0,R14}
1205.prevwordlp     BL      left              ; Find first space to the left
1206                LDRNEB  R0,[R7,R6]        ; or start of line if no spaces
1207                BLNE    testbreak
1208                BNE     prevwordlp
1209.prevwordlp2    TEQ     R6,#0             ; Find first non-space to left
1210                LDMEQFD sp !,{R0,PC}      ; or start of line if all spaces
1211                ADD     R1,R7,R6
1212                LDRB    R0,[R1,#-1]       ; Check char to cursor left
1213                BL      testbreak
1214                LDMNEFD sp !,{R0,PC}
1215                BL      _left             ; If it's a space, move left and
1216                B       prevwordlp2       ; try again
1217.toggleinsert   TST     R8,#fPasswd
1218                EOREQ   r8,r8,#fOver%     ; Toggle overtype flag
1219                BEQ     updatecursor      ; R14 is set to nextchar
1220                MOV     PC,R14
1221; Remove current line from history (if not at end)
1222.removeline     TST     R8,#fPasswd
1223                MOVNE   PC,R14
1224                LDR     R0,[r9,#cur]
1225                CMN     R0,#-(-1)
1226                BLNE    delhistent        ; r0 points to line to delete
1227;                BL      clearline         ; Remove line, but *don't* reset
1228;                B       nextchar          ; current history pointer
1229;
1230.delline        BL      clearline         ; Ctrl-U means clear displayed line
1231                BL      modified
1232;
1233.ignore         B       nextchar
1234.showcomp       TST     R8,#fPasswd
1235                ORREQ   R8,R8,#fShowComp
1236                BEQ     completefnm       ; R14 is set to nextchar
1237                MOV     PC,R14
1238.completeshow
1239.dotcshcompshow ORR     R8,R8,#fTcsh OR fShowComp
1240.complete
1241.dotcshcomp     ORR     R8,R8,#fTcsh
1242.completenext
1243.docompletion   B       completefnm       ; R14 is set to nextchar
1244.completeprev   TST     R8,#fPasswd
1245                ORREQ   R8,R8,#fCompRev   ; (4DOS &) backwards
1246                BEQ     completefnm       ; R14 is set to nextchar
1247                MOV     PC,R14
1248.setmark        TST     R8,#fPasswd
1249                MOVNE   PC,R14
1250                MOV     R11,R6
1251.beepignore     B       beep              ; R14 is set to nextchar
1252; Allowing COPYing is probably bad news in a Taskwindow, so only allow this
1253; if cursor key state was *FX4,0 on entry. NB Zap takes over COPYing in its
1254; Taskwindows, so it works fine and we never get here.
1255.copy           TST     r8,#fCopy%        ; Allow screen COPYing iff entered
1256                BEQ     nextchar          ; with *FX4,0
1257                EOR     r8,r8,#fCopying   ; Toggle fCopying and *FX4 state
1258.copyjoin       TST     r8,#fCopying
1259                MOVNE   R1,#0             ; *FX4,0 for copying
1260                MOVEQ   R1,#2             ; *FX4,2 for not copying
1261                MOV     R0,#4
1262                SWI     XOS_Byte          ; Do *FX4,x (corrupts r1,r2)
1263                BNE     nextchar
1264                BL      joincopycursors
1265                BL      updatecursor      ; If we stopped, reset cursor shape
1266                B       nextchar
1267; Exchange mark with cursor
1268.swapmark
1269.swapmarkcursor TST     R8,#fPasswd
1270                MOVNE   PC,R14
1271                STMFD   sp !,{R1,R14}
1272                MOV     R1,R6
1273.swapmarklp     CMP     R6,R11            ; Which way do we go?
1274                MOVEQ   R11,R1
1275                LDMEQFD sp !,{R1,PC}
1276                BLT     swapmark_right
1277                BL      _left
1278                B       swapmarklp
1279.swapmark_right BL      _right
1280                B       swapmarklp
1281.deltoend
1282.killeol        B       killeolind
1283; Delete region between mark and cursor
1284.cut
1285.wipe           B       __wipe
1286; Corrupts r0-r2
1287.delword        TST     R8,#fPasswd
1288                MOVNE   PC,R14
1289                MOV     R2,R6
1290.delwordlp      BL      ldrr0testbreak
1291                ADDEQ   R6,R6,#1
1292                BEQ     delwordlp         ; Delete until non-break reached
1293.delwordlp2     BL      ldrr0testbreak
1294                ADDGT   R6,R6,#1
1295                BGT     delwordlp2        ; Delete until break or eol found
1296                SUBS    R1,R6,R2
1297                MOV     R6,R2
1298                B       jointstuff
1299; Suck the tail of the line one char to the left
1300.deletenext
1301.deleteright
1302.suckuptail     TST     R8,#fPasswd
1303                MOVNE   PC,R14
1304                STMFD   sp !,{R0,R14}
1305                LDRB    R14,[R7,R6]
1306                TEQ     R14,#13
1307                LDMEQFD sp !,{R0,PC}
1308                CMP     R6,R11
1309                SUBLT   R11,R11,#1        ; Adjust posn of mark
1310                ADD     R0,R7,R6
1311.suckuptaillp   LDRB    R14,[R0,#1]!      ; Move any chars to the right of
1312                STRB    R14,[R0,#-1]      ; cursor down one byte in memory
1313                TEQ     R14,#13
1314                BNE     suckuptaillp
1315; R0 must be non-zero here
1316;               MOV     R0,#1             ; Space needed at end
1317                BL      redrawtail
1318                LDMFD   sp !,{R0,PC}
1319.delete
1320.deleteleft     LDRB    R0,[R7,R6]
1321                BL      del
1322                BEQ     nextchar          ; Ignore if at start of line
1323                BL      modified
1324                TEQ     R0,#13            ; Put in new CR if the cursor was
1325                STREQB  R0,[R7,R6]        ; at the end of the line
1326                BEQ     nextchar          ; and exit
1327                TST     r8,#fOver%        ; Overtype mode ?
1328                MOVNE   R0,#ASC" "        ; Store a space, unlike RKL
1329                STRNEB  R0,[R7,R6]
1330                BLEQ    suckuptail        ; Insert mode is pretty simple
1331                B       nextchar
1332.wipehistory    BL      erasethisbuf
1333.erasebufjoin   BL      clearline         ; Clear line
1334                B       nextchar
1335.wipeallhistory BL      eraseallbufs
1336                B       erasebufjoin
1337.paste
1338.yank           TST     R8,#fPasswd
1339                MOVNE   PC,R14
1340                LDR     R1,[R9,#yankbuf]
1341                TEQ     R1,#0             ; See if there's anyting to yank
1342.yanklp         LDRNEB  R0,[R1],#1
1343                CMPNE   R0,#31
1344                BLE     nextchar
1345                BL      printins
1346                B       yanklp
1347;!HACK! what about the mark?  This works like Zap does...
1348.swapchars
1349.transpose      B       __transpose
1350.quote          SWI     XOS_ReadC
1351                BCS     badreadc
1352                TEQ     R0,#0
1353                BNE     vanilla
1354                SWI     XOS_ReadC
1355                BCS     badreadc
1356                TEQ     R0,#0
1357                BNE     nextchar          ; Ignore extended key codes
1358; Treat key press as old OS_ReadLine would
1359.vanilla        CMP     R0,#13            ; RETURN/Ctrl-M ?
1360                BEQ     enter             ; Put in history
1361                CMP     R0,#10            ; Ctrl-J ?
1362                BEQ     return            ; Don't put in history
1363                CMP     R0,#ASC"U"-64     ; Ctrl-U ?
1364                BEQ     delline
1365                CMP     R0,#&1B           ; ESCAPE hit ?
1366                BEQ     escape
1367                TEQ     R0,#8             ; Ctrl-H or DELETE?
1368                TEQNE   R0,#127
1369                BEQ     deleteleft
1370                CMP     R0,#ASC" "        ; Don't put ctrl-chars in buffer -
1371                BLO     outctrlchar       ; just echo them (like OS_ReadLine)
1372                BL      winkey
1373                BL      printable
1374                B       nextchar
1375; /X corrupts R0
1376.cup
1377.oldesthist     B       __cup
1378; CTRL-Down Cursor hit - retrieve most recent history line; corrupts r0,r1
1379.cdown
1380.latesthist     B       __cdown
1381;corrupts r0,r1
1382.up
1383.uphistreq      TST     R8,#fPasswd
1384                MOVNE   PC,R14
1385                BL      addnewhistifmod   ; Retrieve next oldest history line
1386                LDR     R0,[R9,#cur]
1387                CMN     R0,#-(-1)
1388                LDREQ   R0,[R9,#end]      ; cur=-1 => at end
1389                SUB     R0,R0,#1
1390                LDR     R1,[R9,#buf]
1391                CMP     R0,R1             ; Patched in 2.53a
1392                BLS     go_blankgap
1393.uphistreqlp    LDRB    R14,[R0,#-1]!
1394                TEQ     R14,#13
1395                BNE     uphistreqlp
1396                ADD     R0,R0,#1
1397                BL      fetchhist
1398                B       nextchar
1399.go_blankgap    BL      dispblankgap      ; Patched in 2.53a
1400                B       nextchar          ; Patched in 2.53a
1401; /X corrupts R0
1402.down
1403.downhistreq    TST     R8,#fPasswd
1404                MOVNE   PC,R14
1405                BL      addnewhistifmod   ; Retrive next most recent history
1406                LDR     R0,[R9,#cur]      ; line
1407                CMN     R0,#-(-1)         ; If we're displaying a blank line,
1408                BEQ     oldesthist        ; then wrap around
1409.downhistreqlp  LDRB    R14,[R0],#1       ; Scan to end of current
1410                CMP     R14,#13           ; history line
1411                BGT     downhistreqlp
1412                BLT     go_blankgap       ; If last entry then display blank
1413                BL      fetchhist         ; Retrieve the entry
1414                B       nextchar
1415.sup
1416.uphistmatch    TST     R8,#fPasswd
1417                BEQ     uphistmatchsub
1418                MOV     PC,R14
1419.sdown
1420.dnhistmatch    TST     R8,#fPasswd
1421                BEQ     dnhistmatchsub
1422                MOV     PC,R14
1423.badreadc                                 ; Here for now...
1424.escape         TST     r8,#fCopying
1425                ORREQ   r8,r8,#fEsc%      ; Set ESCAPE flag
1426                BEQ     esc_gotoend
1427                MOV     R0,#124
1428                SWI     XOS_Byte
1429.uncopy         BIC     r8,r8,#fCopying
1430                B       copyjoin
1431.esc_gotoend    BL      gotoend
1432                B       leaveedit
1433.enter          TST     R8,#fPasswd
1434                BNE     common
1435                BL      checkevents
1436                BL      striptildes
1437                BL      addnewhist
1438                B       common
1439.return         TST     R8,#fPasswd
1440                BNE     common
1441                BL      checkevents
1442                BL      striptildes
1443.common         BL      gotoend           ; Goto end of line
1444                SWI     XOS_NewLine       ; Print a newline
1445.leaveedit      LDR     R14,[R9,#taskh]   ; Copy taskh to flag the "current"
1446                STR     R14,[R12,#lastth] ; buffer in *Recall and *EdStatus
1447                LDMFD   sp !,{R0-R4,R11,PC}
1448; f0 ... f9 or f10 ... f12 - lower nybble is assumed to be fkey number
1449.fnkey          BL      winkey
1450                AND     R0,R0,#&0F        ; Only want bottom nybble
1451                CMP     R0,#10
1452                ADDLT   R2,R0,#ASC"0"     ; R2 = ASC"n" for F<n> (n a digit)
1453                ADDGE   R2,R0,#ASC"0"-10  ; R2 = ASC"n" for F1<n> (n a digit)
1454                MOVGE   R2,R2,ASL #8      ; then R2 = (R1<<8)+ASC"1"
1455                ADDGE   R2,R2,#ASC"1"
1456; !HACK! what if expansion already in progress??? Possible?
1457; abandon it is the current approach
1458                LDR     R0,[R9,#fkeybuf]
1459                TEQ     R0,#0
1460                MOVEQ   R0,#(fkeybuff_len+8)
1461                BLEQ    malloc
1462                TEQ     R0,#0
1463                BEQ     beep_nextchar     ; If malloc failed, beep & ignore
1464                STR     R0,[R9,#fkeybuf]
1465                ADD     R1,R0,#8
1466                LDR     R0,keyvar
1467                STMFD   sp !,{R0,R2}      ; Stick Key$<number> on the stack
1468                MOV     R0,sp
1469                MOV     R2,#fkeybuff_len
1470                MOV     R3,#0
1471                MOV     R4,#3             ; Return expanded as string
1472                SWI     "XOS_ReadVarVal"  ; Read fnkey defn
1473                ADD     sp,sp,#8          ; Restore stack pointer
1474                MOVVS   R2,#0             ; If error, fake 0 bytes read
1475                TEQ     R2,#0
1476                ADDNE   R3,R1,R2
1477                SUBNE   R3,R3,#1
1478                STRNE   R3,[R1,#-8]       ; Ptr to last char
1479                STRNE   R2,[R1,#-4]       ; Characters left in buffer
1480                BNE     nextchar
1481                SUB     R0,R1,#8          ; If no fnkey defn, free the buffer
1482                BL      free              ; and bail out
1483                STR     R0,[R9,#fkeybuf]
1484                B       nextchar
1485.beep_nextchar  BL      beep
1486                B       nextchar
1487;--- This lot's here to keep the keytable code happy
1488.winkey         ; bit pattern =  %1011x1xyy (yy != 11)
1489MOV PC,R14
1490                STMFD   sp !,{R14}
1491                EOR     R14,R0, #%101101000
1492                BIC     R14,R14,#%000010100
1493                CMP     R14,#2            ; 0-2 = Logo or Menu
1494                LDMHIFD sp !,{PC}         ; (Z clear)
1495                TST     R0,#16            ; convert to internal key number
1496                ORRNE   R0,R0,#&20
1497                TST     R0,#4
1498                BIC     R0,R0,#&14
1499                ORRNE   R0,R0,#&10
1500;!              TST     R0,R0,LSR #2      ; stick b1 in C flag (set if RH Logo)
1501;!              TEQ     R0,R0             ; force Z clear
1502                LDMFD   sp !,{PC}
1503.__transpose    TST     R8,#fPasswd
1504                MOVNE   PC,R14
1505                LDRB    R0,[R7,R6]
1506                TEQ     R0,#13            ; Check not on last char
1507                BEQ     nextchar
1508                BLNE    left              ; Check not on first char
1509                LDRB    R1,[R7,R6]
1510                STRB    R0,[R7,R6]
1511                BL      writec
1512                MOV     R0,R1
1513                BL      writec
1514                ADD     R6,R6,#2
1515                BL      _left
1516                STRB    R1,[R7,R6]
1517                B       nextchar
1518.__wipe         TST     R8,#fPasswd
1519                MOVNE   PC,R14
1520                CMP     R6,R11            ; If cursor to right of mark, swap
1521                BLGT    swapmark          ; them
1522                SUBS    R1,R11,R6         ; Amount to delete
1523.jointstuff     BEQ     nextchar          ; If none, give up
1524                BL      mallocyank        ; malloc R1+1 and return ptr in R0
1525.wipelp         LDRB    R14,[R7,R6]       ; Copy into yank buffer
1526                STRB    R14,[R0],#1
1527                BL      suckuptail
1528                SUBS    R1,R1,#1
1529                BNE     wipelp
1530;                MOV     R1,#0
1531                STRB    R1,[R0]           ; Terminate with zero byte
1532                B       nextchar
1533.__cup          TST     R8,#fPasswd
1534                MOVNE   PC,R14
1535                BL      addnewhistifmod   ; Ctrl-Up Cursor hit
1536                LDR     R0,[R9,#buf]
1537                LDRB    R14,[R0],#1
1538                TEQ     R14,#0            ; Check history not empty
1539                LDRNE   R14,[R9,#cur]
1540                TEQNE   R0,R14
1541                STRNE   R0,[R9,#cur]      ; Move to top
1542                BLNE    fetchhist         ; Only display if different
1543                B       nextchar
1544.__cdown        TST     R8,#fPasswd
1545                MOVNE   PC,R14
1546                LDR     R0,[R9,#cur]      ; Start from current posn, checking
1547                LDR     R14,[R9,#end]     ; we're not already at the bottom
1548                SUB     R14,R14,#2        ; CDOWN on typed line should be nop
1549                CMP     R14,R0
1550                BLO     nextchar          ; NB Unsigned compare to -1 is LO
1551                MOV     R1,R0
1552.latesthistlp   LDRB    R14,[R0],#1       ; Hammer thru' to buffer end
1553                TEQ     R14,#0
1554                BNE     latesthistlp
1555.latesthistlp2  LDRB    R14,[R0,#-1]!     ; Now retreat to beginning of
1556                TEQ     R14,#13           ; last entry
1557                BNE     latesthistlp2
1558                ADD     R0,R0,#1
1559                CMP     R0,R1
1560                BLNE    fetchhist         ; Retrieve if changed
1561                B       nextchar
1562;---------------------------------------------------------------------------
1563; corrupts R0-R3
1564.killeolind     MOV     R2,R6             ; Note current position
1565                BL      gotoend           ; Goto end of line
1566                SUBS    R1,R6,R2          ; See how far it was
1567                BEQ     nextchar          ; If at end of line, do nothing
1568                BL      mallocyank        ; malloc R1+1 and return ptr in R0
1569                MOV     R3,R0
1570                MOV     R6,R2
1571                ADD     R2,R6,R7          ; Point R2 at current position
1572.killeollp      LDRB    R14,[R2,R1]
1573                STRB    R14,[R3,R1]
1574                SUBS    R1,R1,#1
1575                SWIGE   XOS_WriteI+127    ; Delete back to r6
1576                BGE     killeollp
1577                MOV     R0,#13
1578                STRB    R0,[R7,R6]        ; Truncate line
1579                CMP     R11,R6            ; Adjust posn of mark if it was
1580                MOVGT   R11,R6            ; in the deleted bit
1581                B       nextchar
1582.mallocyank     STMFD   sp !,{R14}
1583                LDR     R0,[R9,#yankbuf]
1584                BL      free
1585                ADD     R0,R1,#1
1586                BL      malloc
1587                STR     R0,[R9,#yankbuf]
1588                LDMFD   sp !,{PC}
1589; Primitive right
1590._right         STMFD   sp !,{R0,R14}
1591                SWI     XOS_WriteI+9
1592                ADD     R6,R6,#1
1593                LDMFD   sp !,{R0,PC}
1594; Primitive left
1595._left          STMFD   sp !,{R0,R14}
1596                SWI     XOS_WriteI+8
1597                SUB     R6,R6,#1
1598                LDMFD   sp !,{R0,PC}
1599; /X EQ iff already at start of line
1600.del            STMFD   sp !,{R0,R14}
1601                TEQ     R6,#0             ; At start of line ?
1602                SUBNE   R6,R6,#1          ; If not, decrement R6 and delete
1603                SWINE   XOS_WriteI+127    ; left
1604                LDMFD   sp !,{R0,PC}
1605; A bit of a fudge, but never mind...
1606; Don't try this in a taskwindow as OS_Byte,165 won't work
1607; NB OS_Byte,134 reads the *input* cursor, which is the blob during copying
1608.joincopycursors
1609                STMFD   sp !,{r0-r2,r14}
1610                MOV     R0,#165
1611                SWI     XOS_Byte          ; Read output cursor pos to (R1,R2)
1612                SWIVC   XOS_WriteI+13     ; Send CR to join copy cursor
1613                SWIVC   XOS_WriteI+31     ; And then reposition cursor
1614                MOVVC   R0,R1
1615                SWIVC   XOS_WriteC
1616                MOVVC   R0,R2
1617                SWIVC   XOS_WriteC
1618                LDMFD   sp !,{r0-r2,PC}
1619.uphistmatchsub STMFD   sp !,{R0-R5,R14}  ; Go back to history line with
1620;                BL      addnewhistifmod   ; start matching whole of latest
1621                BL      caselessteq_init
1622                LDR     R2,[R9,#buf]      ; line
1623                TST     R8,#fEdit%
1624                LDREQ   R4,[R9,#match]
1625                TSTEQ   R4,#1<<31         ; EQ iff positive
1626                BEQ     uhmkeepgoing
1627                ADD     R4,R6,R7
1628.uphistmatchlp  LDRB    R14,[R4],#1
1629                TEQ     R14,#13
1630                BNE     uphistmatchlp
1631                SUB     R4,R4,R7
1632                SUB     R4,R4,#1
1633                STR     R4,[R9,#match]
1634.uhmkeepgoing   LDR     R5,[r9,#cur]      ; R5->current history line
1635                CMN     R5,#-(-1)
1636                LDREQ   R5,[R9,#end]      ; If at bottom
1637                TEQ     R2,R5             ; Catch buf=end if it's empty
1638.uhmbiglp       SUBNE   R5,R5,#1
1639                TEQ     R2,R5
1640                BEQ     uhmbeep           ; If we've hit the top
1641.uphistmatchlp2 LDRB    R14,[R5,#-1]!     ; Skip to beginning of prev
1642                TEQ     R14,#13           ; line in history
1643                BNE     uphistmatchlp2
1644                ADD     R5,R5,#1
1645                SUBS    R3,R4,#1
1646                BMI     uhmautomatch      ; Page up/down on empty line
1647.uphistmatchlp3 LDRB    R1,[R5,R3]
1648                LDRB    R0,[R7,R3]
1649                BL      caselessteq       ; Corrupts R1
1650                BNE     uhmbiglp
1651                SUBS    R3,R3,#1
1652                BPL     uphistmatchlp3
1653                ;match!
1654.dnmautomatch
1655.uhmautomatch   MOV     R0,R5
1656                BL      fetchhist
1657                LDMFD   sp !,{R0-R5,PC}
1658.uhmbeep
1659.dnmbeep
1660.dhmbeep        LDMFD   sp !,{R0-R5,R14}
1661                B       beep
1662;should stack same regs as uphistmatch
1663.dnhistmatchsub STMFD   sp !,{R0-R5,R14}  ; Go forwards to history line with
1664;                BL      addnewhistifmod   ; start matching whole of latest
1665                BL      caselessteq_init
1666                LDR     R2,[R9,#buf]      ; line
1667                TST     R8,#fEdit%
1668                LDREQ   R4,[R9,#match]
1669                TSTEQ   R4,#1<<31         ; EQ iff positive
1670                BEQ     dnmkeepgoing
1671                ADD     R4,R6,R7
1672.dnhistmatchlp  LDRB    R14,[R4],#1
1673                TEQ     R14,#13
1674                BNE     dnhistmatchlp
1675                SUB     R4,R4,R7
1676                SUB     R4,R4,#1
1677                STR     R4,[R9,#match]
1678.dnmkeepgoing   LDR     R5,[r9,#cur]      ; R5->current history line
1679                CMN     R5,#-(-1)
1680                BEQ     dnmbeep           ; At the bottom
1681.dnmbiglp
1682.dnhistmatchlp2 LDRB    R14,[R5],#1       ; Skip to beginning of next
1683                CMP     R14,#13           ; line in history
1684                BGT     dnhistmatchlp2
1685                BLT     dhm_hitbottom
1686                SUBS    R3,R4,#1
1687                BMI     dnmautomatch      ; Page up/down on empty line
1688.dnhistmatchlp3 LDRB    R1,[R5,R3]
1689                LDRB    R0,[R7,R3]
1690                BL      caselessteq       ; Corrupts R1
1691                BNE     dnmbiglp
1692                SUBS    R3,R3,#1
1693                BPL     dnhistmatchlp3
1694                B       dnmautomatch
1695;
1696.dhm_hitbottom  LDR     R14,[R9,#match]   ; No more matches, but if match=0
1697                TEQ     R14,#0            ; first pageup was from a blank
1698                BNE     dhmbeep           ; line, so recall one
1699                BL      dispblankgap
1700                LDMFD   sp !,{R0-R5,PC}
1701; line has been cleared by ^L or similar, so redraw it and reposition cursor
1702.redrawline     STMFD   sp !,{R0,R1,R14}
1703                MOV     R1,R7
1704.redrawlp       LDRB    R0,[R1],#1        ; Redraw the line
1705                CMP     R0,#13
1706                BEQ     redrawlp_exit
1707                BL      writec
1708                B       redrawlp
1709.redrawlp_exit  SUB     R1,R1,R7
1710                SUBS    R1,R1,R6          ; (# lefts needed to move cursor
1711.returncurslp   SUBNES  R1,R1,#1          ; back to insertion position) +1
1712                SWINE   XOS_WriteI+8
1713                BNE     returncurslp
1714                LDMFD   sp !,{R0,R1,PC}
1715.outctrlchar    TST     R8,#fEchoBuf
1716                BNE     nextchar
1717                SWI     XOS_WriteC        ; If an error corrupts R0,
1718                TEQ     R0,#ASC"L"-64     ; then redraw won't happen
1719                TEQNE   R0,#30            ; which is fine
1720                BLEQ    prompt_and_line
1721                B       nextchar
1722.prompt_and_line
1723                STMFD   sp !,{R14}
1724                BL      display_prompt
1725                BL      redrawline        ; Redraw line if nuked
1726                LDMFD   sp !,{PC}
1727; Force insert mode for this character
1728.printins       STMFD   sp !,{R8,R14}
1729                BIC     R8,R8,#fOver%
1730                BL      printable
1731                LDMFD   sp !,{R8,PC}
1732; Put a printable character (&20-&7E, &80-&FF) in the buffer and on screen
1733; used by vanilla, yank, and filename completion code
1734; /E R0=char /X R6,R11 updated
1735.printable      CMP     R0,R8,LSR#24      ; Check char within range
1736                MOVLT   PC,R14
1737                STMFD   sp !,{R0,R1,R14}
1738                AND     R1,R8,#255
1739                CMP     R0,R1
1740                LDMGTFD sp !,{R0,R1,PC}
1741                TST     r8,#fOver%        ; Overstrike mode ?
1742                BEQ     trickyinsert
1743                LDRB    R1,[R7,R6]        ; BEEP if cursor at end of line
1744                TEQ     R1,#13            ; and buffer is full
1745                TEQEQ   R6,R10
1746                BEQ     beepnexitifeq
1747                STRB    R0,[R7,R6]        ; Store char in buffer and
1748                BL      writec            ; display it on screen
1749                ADD     R6,R6,#1
1750                CMP     R1,#13            ; Replace CR if cursor was at the
1751                STREQB  R1,[R7,R6]        ; end of the line
1752                BL      modified
1753                BL      checktildes
1754                LDMFD   sp !,{R0,R1,PC}
1755.beepnexitifeq  LDMFD   sp !,{R0,R1,R14}
1756                B       beep
1757                ;
1758.trickyinsert   MOV     R1,R6
1759.ti_findeol     LDRB    R14,[R7,R1]
1760                TEQ     R14,#13
1761                ADDNE   R1,R1,#1
1762                BNE     ti_findeol
1763                CMP     R1,R10            ; Line full ?
1764                BEQ     beepnexitifeq     ; Yes, so BEEP and return
1765.ti_movelp      LDRB    R14,[R7,R1]       ; Move any chars to the right of
1766                ADD     R1,R1,#1          ; the cursor up one byte in memory
1767                STRB    R14,[R7,R1]
1768                SUB     R1,R1,#2
1769                CMP     R1,R6
1770                BGE     ti_movelp
1771                STRB    R0,[R7,R6]        ; Store char
1772                CMP     R6,R11            ; If inserting to left of mark
1773                ADDLT   R11,R11,#1        ; then move it right too
1774                ADD     R6,R6,#1
1775                BL      writec            ; Display char
1776                MOV     R0,#0             ; No space needed
1777                BL      redrawtail
1778                LDMFD   sp !,{R0,R1,PC}
1779;/E R9 -> current instance
1780;!HACK! needs adjusting for client buffer case...
1781.erasethisbuf   STMFD   sp !,{R0-R3,R14}  ; Delete contents of buffer used
1782                LDR     R1,[R9,#buf]      ; by current instance and adjust
1783                LDR     R14,[R12,#head]   ; ptrs of other instances using
1784                ADD     R2,R1,#1          ; the same buffer
1785                MOV     R0,#0
1786                STRB    R0,[R1]           ; Mark buffer empty
1787                MVN     R3,#NOT(-1)
1788.erasethisbuflp LDR     R0,[R14,#buf]     ; Adjust ptrs of other instances
1789                TEQ     R0,R1             ; using same buffer
1790                BNE     erasethisbufsk
1791                STR     R2,[R14,#end]
1792                LDR     R0,[R14,#cur]
1793                CMP     R0,#0             ; Change if not 0 (inactive) or
1794                STRGT   R3,[R14,#cur]     ; -1 (no change of value)
1795.erasethisbufsk LDR     R14,[R14,#next]
1796                TEQ     R14,#0
1797                BNE     erasethisbuflp
1798                LDMFD   sp !,{R0-R3,PC}
1799.striptildes    STMFD   sp !,{R14}
1800                LDR     R14,[R12,#flags]
1801                TST     R14,#f_NoTildes
1802                LDMNEFD sp !,{PC}         ; Check if tilde expansion disabled
1803.striptildeslp  LDRB    R14,[R7]          ; Remove leading tildes
1804                TEQ     R14,#ASC"~"       ; NB R14=13 if buffer empty
1805                LDMNEFD sp !,{PC}
1806                BL      gotostart
1807                BL      suckuptail
1808                B       striptildeslp
1809.fnkeyexpand    LDR     R2,[R1,#4]
1810                SUBS    R2,R2,#1
1811                STRNE   R2,[R1,#4]
1812                LDR     R0,[R1]
1813                LDRB    R0,[R0,-R2]
1814                BNE     vanilla
1815                MOV     R2,R0
1816                MOV     R0,R1             ; Free buffer if this is the
1817                BL      free              ; last char of the expansion
1818                STR     R0,[R9,#fkeybuf]
1819                MOV     R0,R2
1820                B       vanilla
1821; /X NE iff fShiftPressed, CS iff fCtrlPressed
1822.checkmodkeys   STMFD   sp !,{R0-R2,R14}
1823                MOV     R0,#202
1824                MOV     R1,#0
1825                MOV     R2,#&ff
1826                SWI     XOS_Byte          ; Read keyboard state
1827                MOVS    R0,R1,LSR#7       ; Set C to reflect Ctrl key
1828                TST     R1,#(1<<3)        ; Set Z to reflect Shift key
1829                LDMFD   sp !,{R0-R2,PC}
1830; Clear out all buffers - *EraseHistory
1831.erasehistory   LDR     R12,[R12]
1832; Shift-Ctrl-Delete
1833.eraseallbufs   STMFD   sp !,{R0-R3,R14}
1834                MOV     R1,#0
1835                MVN     R2,#NOT(-1)
1836                LDR     R0,[R12,#head]
1837                B       erasehistin
1838;
1839.erasehistlp    LDR     R14,[R0,#buf]
1840                STRB    R1,[R14],#1       ; Mark buffer empty and
1841                STR     R14,[R0,#end]     ; update buffer end pointer
1842                LDR     R3,[R0,#cur]
1843                TEQ     R3,#0
1844                STRNE   R2,[R0,#cur]      ; Reset cur to -1 if not 0
1845                LDR     R0,[R0,#next]
1846.erasehistin    TEQ     R0,#0
1847                BNE     erasehistlp
1848                LDMFD   sp !,{R0-R3,PC}
1849; /E R0 <> 0 => nuke char on display after end of line
1850.redrawtail     STMFD   sp !,{R0-R2,R14}
1851                MOV     R2,R0
1852                BL      modified
1853                MOV     R1,R6
1854.redrawtaillp   LDRB    R0,[R7,R1]        ; Redisplay the characters
1855                CMP     R0,#13
1856                BEQ     redrawtaillpx
1857                BL      writec
1858                ADD     R1,R1,#1
1859                B       redrawtaillp
1860.redrawtaillpx  TEQ     R2,#0             ; Nuke next character?
1861                SWINE   XOS_WriteI+32     ; 32 beats 9 in !Edit taskwindows
1862                SWINE   XOS_WriteI+127
1863                SUBS    R1,R1,R6          ; Number of lefts needed to move
1864.redrawtaillp2  SWINE   XOS_WriteI+8      ; cursor back to insertion position
1865                SUBNES  R1,R1,#1
1866                BNE     redrawtaillp2
1867                BL      checktildes
1868                LDMFD   sp !,{R0-R2,PC}
1869.dispblankgap   STMFD   sp !,{R14}
1870                MVN     R14,#NOT(-1)      ; Set current history to bottom
1871                STR     R14,[R9,#cur]
1872                BL      clearline         ; Clear line
1873                LDMFD   sp !,{PC}
1874.modified       STMFD   sp !,{R0,R14}
1875                ORR     r8,r8,#fEdit%     ; Set modified flag
1876                LDR     r14,[R9,#end]
1877                SUB     r14,r14,#1
1878                STR     r14,[R9,#cur]     ; Set current history to end
1879                MVN     r14,#NOT(-1)
1880                STR     r14,[R9,#match]   ; Reset pageup/down counter
1881                TST     r8,#fKeep4D
1882                BLEQ    freecontext       ; Reset file completing counter
1883                LDMFD   sp !,{R0,PC}
1884; Check for leading tilde and expand if unique match
1885.checktildes    STMFD   sp !,{R0-R4,R14}
1886                BL      caselessteq_init
1887                LDR     R14,[R12,#flags]
1888                TST     R14,#f_NoTildes   ; Check if tilde expansion disabled
1889                LDREQB  R14,[R7]          ; Check for leading tilde
1890                TEQEQ   R14,#ASC"~"       ; (Deals with empty line too)
1891                LDMNEFD sp !,{R0-R4,PC}
1892                LDRB    R14,[R7,#1]
1893                TEQ     R14,#13
1894                LDMEQFD sp !,{R0-R4,PC}   ; Line is just "~"
1895                LDR     R2,[R9,#buf]
1896                MOV     R4,#0
1897                B       checktildesin
1898                ;
1899.trynextpl      ADD     R2,R2,R3
1900.trynextpllp    LDRB    R14,[R2],#1
1901                CMP     R14,#13
1902                BGT     trynextpllp       ; Scan for 0 or 13 - 0 means
1903                BLT     endofhistory      ; no more history
1904                SUB     R2,R2,#1
1905.checktildesin  MOV     R3,#1
1906.matchedpls     LDRB    R0,[R2,R3]
1907                CMP     R0,#13
1908                BLE     trynextpl         ; Line is too short to match
1909                LDRB    R1,[R7,R3]
1910                BL      caselessteq       ; Corrupts R1
1911                BNE     trynextpl
1912                ADD     R3,R3,#1
1913                LDRB    R14,[R7,R3]
1914                CMP     R14,#13
1915                BNE     matchedpls
1916                TEQ     R4,#0
1917; + 1 because R2 is on CR of previous line
1918                ADDEQ   R4,R2,#1          ; R2 is a match - if we find
1919                BEQ     trynextpl         ; another, it isn't unique
1920                LDMFD   sp !,{R0-R4,PC}   ; Match isn't unique
1921                ;
1922.endofhistory   MOVS    R0,R4             ; If we got a unique match
1923                BLNE    fetchhist         ; then recall it
1924                LDMFD   sp !,{R0-R4,PC}
1925.checkevents    STMFD   sp !,{R0-R4,R14}
1926                LDR     R1,[R12,#flags]
1927                TST     R1,#f_NoEvents    ; Check if events disabled
1928                LDRB    R2,[R7]           ; Check for leading "!"
1929                TEQEQ   R2,#ASC"!"        ; (Deals with empty line too)
1930                BEQ     gotbang
1931                TST     R1,#f_NoHatRepl   ; Check if hat replace disabled
1932                TEQEQ   R2,#ASC"^"        ; (Deals with empty line too)
1933                LDMNEFD sp !,{R0-R4,PC}
1934; got a hat...
1935                ADD     R1,R7,#1
1936.checkhatlp     LDRB    R14,[R1],#1
1937                TEQ     R14,#13
1938                TEQNE   R14,#ASC"^"
1939                BNE     checkhatlp
1940                TEQ     R14,#13
1941                LDMEQFD sp !,{R0-R4,PC}   ; No second ^
1942                SUB     R2,R1,#1
1943.checkhatlp2    LDRB    R14,[R2,#1]!      ; Look for third ^
1944                TEQ     R14,#13
1945                TEQNE   R14,#ASC"^"
1946                BNE     checkhatlp2
1947                TEQ     R14,#13
1948                MOVEQ   R3,R2
1949                ADDNE   R3,R2,#1
1950;     ^foo^bar^<-R3
1951; R7-> R1->   <-R2
1952                LDR     R14,[R9,#buf]
1953                LDRB    R14,[R14]
1954                TEQ     R14,#0
1955                LDMEQFD sp !,{R0-R4,R14}  ; No lines in buffer
1956                BEQ     beep
1957                LDR     R4,[R9,#end]
1958                SUB     R0,R4,#1
1959.hatlp          LDRB    R14,[R0,#-1]!
1960                CMP     R14,#32
1961                BGE     hatlp
1962                ADD     R0,R0,#1
1963;     echo foo world
1964; R0->           R4->
1965;
1966; check for string (R7+1), len (R1-R7-2)
1967; in string R0, len (R4-R0-1)
1968; if there, replace with string (r1), len (r2-r1) and append R3
1969                STMFD   sp !,{r5,r6,r8-r9,r11-r12}
1970                MOV     R11,R0
1971                ADD     R5,R7,#1 ; R5 = start of string to look for
1972                SUB     R8,R4,R0
1973                SUB     R8,R8,#1 ; R8 = len of string to search in
1974                SUB     R6,R1,R7
1975                SUBS    R6,R6,#2 ; R6 = len of string to look for
1976                BEQ     hatmatch ; If it's empty, the match at start
1977                SUBS    R8,R8,R6 ; now R8 = # of positions to try
1978                BLT     hatnomatch
1979.hatlp2         SUB     r12,r6,#1
1980.hatlp3         LDRB    r9,[r5,r12]
1981                LDRB    r14,[r11,r12]
1982                TEQ     r9,r14
1983                BNE     hatnext
1984                SUBS    r12,r12,#1
1985                BGE     hatlp3
1986.hatmatch
1987; found a match at r11
1988;
1989;     ^foo^bar^<-R3
1990; R7-> R1->   <-R2
1991;  R5->
1992;     echo foo world
1993; R0->           R4->
1994;     R11->
1995;
1996; memmove(R7+(r4-r0-1)-r6+(r2-r1),r3,strlen(r3)+1); /* do tail */
1997; !HACK! do this bit properly
1998;BL showregs
1999STMFD sp !,{r0}
2000                SUB     R0,R4,R0
2001                SUB     R0,R0,#1
2002                SUB     R0,R0,R6
2003                ADD     R0,R0,R2
2004                SUB     R0,R0,R1
2005                ADD     R0,R0,R7
2006                SUB     R12,R0,#1
2007.hatrepllp0     LDRB    R14,[R12,#1]!
2008                CMP     R14,#32
2009                BGE     hatrepllp0
2010                SUB     R12,R12,R7
2011                CMP     R12,R10
2012LDMGTFD sp !,{r0}
2013                BGT     hatnomatch ; wouldn't fit in buffer
2014                CMP     R3,R0
2015                BLO     hattailrevcopy
2016                BEQ     hattaildone
2017.hatrepllp      LDRB    R14,[R3],#1
2018                STRB    R14,[R0],#1
2019                CMP     R14,#32
2020                BGE     hatrepllp
2021                B       hattaildone
2022;
2023.hattailrevcopy
2024.hatreplrevlp   LDRB    R14,[R3,R12]
2025                STRB    R14,[R0,R12]
2026                SUBS    R12,R12,#1
2027                BGE     hatreplrevlp
2028;
2029.hattaildone
2030LDMFD sp !,{r0}
2031; memcopy(R7+(r11-r0),r5,r6); /* do replace */
2032                ADD     R3,R7,R11
2033                SUB     R3,R3,R0
2034STMFD sp !,{r0}
2035                MOV     R0,R1
2036                SUBS    R4,R2,R1
2037.hatrepllp3     LDRNEB  R14,[R0],#1
2038                STRNEB  R14,[R3],#1
2039                SUBNES  R4,R4,#1
2040                BNE     hatrepllp3
2041LDMFD sp !,{r0}
2042; memcopy(R7,r0,r11-r0); /* do head */
2043                MOV     R3,R7
2044                SUBS    R4,R11,R0
2045.hatrepllp2     LDRNEB  R14,[R0],#1
2046                STRNEB  R14,[R3],#1
2047                SUBNES  R4,R4,#1
2048                BNE     hatrepllp2
2049; memcopy(R7+(r11-r0)+r6,r11+r5,r8); /* do rest */
2050                ADD     R0,R6,R11
2051                ADD     R3,R3,R2
2052                SUB     R3,R3,R1
2053                MOVS    R4,R8
2054.hatrepllp4     LDRNEB  R14,[R0],#1
2055                STRNEB  R14,[R3],#1
2056                SUBNES  R4,R4,#1
2057                BNE     hatrepllp4
2058;
2059                LDMFD   sp !,{r5,r6,r8-r9,r11-r12}
2060                BL      showline
2061                LDMFD   sp !,{R0-R4,PC}
2062;
2063.hatnext        ADD     R11,R11,#1
2064                SUBS    R8,R8,#1
2065                BGE     hatlp2
2066.hatnomatch     LDMFD   sp !,{r5,r6,r8-r9,r11-r12}
2067                LDMFD   sp !,{R0-R4,R14}
2068; !HACK complain a bit more
2069                B       beep
2070;
2071.gotbang        MOV     R1,R7
2072                LDRB    R3,[R1,#1]!
2073                TEQ     R3,#ASC"!"        ; !! means !-1
2074                MVNEQ   R2,#NOT(-1)
2075                ADDEQ   R1,R1,#1
2076                BEQ     chkev_neg
2077                TEQ     R3,#ASC"-"
2078                MOVNE   R14,R3
2079                LDREQB  R14,[R1,#1]!
2080                SUB     R2,R14,#ASC"0"
2081                CMP     R2,#10
2082                LDMHSFD sp !,{R0-R4,PC}   ; Not a digit...
2083.checkeventlp   LDRB    R14,[R1,#1]!
2084                SUB     R14,R14,#ASC"0"
2085                CMP     R14,#10
2086                ADDLO   R2,R2,R2,ASL#2
2087                ADDLO   R2,R14,R2,ASL#1   ; R2 = R2*10 + R14
2088                BLO     checkeventlp
2089                TEQ     R3,#ASC"-"
2090                RSBEQ   R2,R2,#0
2091                ; R2 = event number (1 is first line), -ve means from bottom
2092                ; R1 -> rest of line (after !! !-4 !7 etc)
2093                BEQ     chkev_neg
2094                LDR     R3,[R9,#buf]
2095                MOV     R0,R2
2096.chkev_lp
2097.chkev_lp2      LDRNEB  R14,[R3],#1
2098                CMPNE   R14,#13
2099                BGT     chkev_lp2         ; Skip a line
2100                BLT     chkev_notfound
2101                SUBS    R0,R0,#1          ; EQ means zero means end of buffer
2102                BNE     chkev_lp          ; Otherwise decrement count
2103                B       chkev_Done
2104;
2105.chkev_neg      LDR     R3,[R9,#end]
2106                LDR     R4,[R9,#buf]
2107                MOV     R0,R2
2108                SUB     R3,R3,#1
2109.chkevneg_lp    CMP     R3,R4             ; Check not start of buf
2110                BEQ     chkev_notfound
2111.chkevneg_lp2   LDRNEB  R14,[R3,#-1]!
2112                CMPNE   R14,#13
2113                BGT     chkevneg_lp2      ; Skip a line
2114                ADDS    R0,R0,#1          ; EQ means zero means end of buffer
2115                BNE     chkevneg_lp       ; Otherwise decrement count
2116                ADD     R3,R3,#1
2117;
2118.chkev_Done     ; R3 -> buffered history entry to recall
2119                ; R10 is max length
2120                SUB     R0,R1,#1
2121.chkev_lp3      LDRB    R14,[R0,#1]!
2122                TEQ     R14,#13
2123                BNE     chkev_lp3
2124                SUB     R0,R0,R1          ; R0 = length of tail of line
2125                SUB     R2,R3,#1
2126.chkev_lp4      LDRB    R14,[R2,#1]!
2127                CMP     R14,#32
2128                BGE     chkev_lp4
2129                SUB     R2,R2,R3          ; R2 = length of recalled line
2130                ADD     R14,R0,R2         ; R14 = total len of combined line
2131                CMP     R14,R10
2132                BGE     chkev_notfound    ; Expanded line too long ):
2133                                          ; (use GE to allow for terminator)
2134; reverse/forward copy tail of line by r2-(r1-r7) bytes
2135; ie from r1 to r7+r2 for r0+1 bytes
2136                ADD     R0,R0,#2
2137                ADD     R4,R7,R2
2138                CMP     R1,R4
2139                BGT     chkev_forcopy
2140.chkev_lp5      SUBS    R0,R0,#1
2141                LDRB    R14,[R1,R0]
2142                STRB    R14,[R4,R0]
2143                BNE     chkev_lp5
2144                B       chkev_skp
2145;
2146.chkev_forcopy
2147.chkev_lp5f     SUBS    R0,R0,#1
2148                LDRB    R14,[R1],#1
2149                STRB    R14,[R4],#1
2150                BNE     chkev_lp5f
2151;
2152.chkev_skp
2153.chkev_lp6      SUBS    R2,R2,#1          ; Copy recalled line from history
2154                LDRB    R14,[R3,R2]       ; into buffer
2155                STRB    R14,[R7,R2]
2156                BNE     chkev_lp6
2157                BL      showline
2158                LDMFD   sp !,{R0-R4,PC}
2159.chkev_notfound LDMFD   sp !,{R0-R4,R14}  ; No such event
2160                B       beep
2161; Displays current line...
2162.showline       STMFD   sp !,{r0,r14}
2163                SWI     XOS_NewLine
2164                MOV     R0,R7
2165                BL      writecr
2166                SWI     XOS_NewLine
2167                LDMFD   sp !,{r0,PC}
2168.writecr        STMFD   sp !,{R0,R1,R14}
2169                MOV     R1,R0
2170.wcr_lp         LDRB    R0,[R1],#1
2171                CMP     R0,#32
2172                LDMLTFD sp !,{R0,R1,PC}
2173                BL      writec
2174                B       wcr_lp
2175]
2176IF 0 THEN
2177[OPTA%
2178;!HACK! this is a bit nasty - also doesn't cope unless 1-or-all history
2179; push R0 in case XOS_WriteI returns an error
2180.dump           STMFD   sp !,{R0,R1,R9,R14}
2181                LDR     R12,[R12]
2182                LDR     R9,[R12,#head]
2183                TEQ     R9,#0
2184                LDMEQFD sp !,{R0,R1,R9,PC}
2185                LDR     R1,[R12,#lastth]
2186.dumpinstlp     LDR     R14,[R9,#taskh]
2187                TEQ     R1,R14
2188                SWIEQ   XOS_WriteI+ASC"*" ; Mark current buffer
2189                SWINE   XOS_WriteI+ASC" "
2190LDR R0,[R9,#buf]
2191BL outhex
2192SWI XOS_NewLine
2193                LDR     R9,[R9,#next]
2194                TEQ     R9,#0
2195                BNE     dumpinstlp
2196                LDMFD   sp !,{R0,R1,R9,PC}
2197]
2198ENDIF
2199[OPTA%
2200;!HACK! this is a bit nasty - also doesn't cope unless 1-or-all history
2201; push R0 in case XOS_WriteI returns an error
2202.recall         STMFD   sp !,{R0,R1,R9,R14}
2203]
2204IF 0 THEN
2205[OPTA%
2206BL dump
2207]
2208ENDIF
2209[OPTA%
2210                LDR     R12,[R12]
2211                LDR     R9,[R12,#head]
2212                TEQ     R9,#0
2213                LDMEQFD sp !,{R0,R1,R9,PC}
2214                LDR     R14,[R12,#flags]
2215                TST     R14,#f_LocalHist  ; Local history?
2216                BEQ     recall_rcbuffer
2217                LDR     R1,[R12,#lastth]
2218.recallinstlp   LDR     R14,[R9,#taskh]
2219                TEQ     R1,R14
2220]
2221IF oldrecall% THEN
2222[OPTA%
2223                SWIEQ   XOS_WriteI+ASC"*" ; Mark current buffer
2224                BL      recallbuffer
2225                LDR     R9,[R9,#next]
2226                TEQ     R9,#0
2227]
2228ELSE
2229[OPTA%
2230                BEQ     recall_rcbuffer
2231                LDRNE   R9,[R9,#next]
2232                TEQNE   R9,#0
2233]
2234ENDIF
2235[OPTA%
2236                BNE     recallinstlp
2237                LDMFD   sp !,{R0,R1,R9,PC}
2238.recall_rcbuffer
2239                BL      recallbuffer      ; If not, display buffer contents
2240                LDMFD   sp !,{R0,R1,R9,PC}; and exit
2241;/E R9->instance
2242.recallbuffer   STMFD   sp !,{R0-R4,R14}
2243                LDR     R2,[R9,#buf]
2244                LDRB    R14,[R2],#1
2245                TEQ     R14,#0
2246                BEQ     recallempty
2247                MOV     R3,#0             ; History line counter
2248                MOV     R1,#4             ; Pad width
2249                ADR     R0,szrecallheader
2250                BL      pprint
2251.recallloop     ADD     R3,R3,#1
2252                MOV     R0,R3
2253                BL      outpadval
2254                SWI     XOS_WriteI+ASC":"; Output "  nn<colon>"
2255.recallloop2    LDRB    R0,[R2],#1
2256                CMP     R0,#13
2257                SWIGT   XOS_WriteC
2258                BGT     recallloop2
2259                SWI     XOS_NewLine
2260                BEQ     recallloop        ; 0 marks end of history
2261                LDMFD   sp !,{R0-R4,PC}
2262                ;
2263.recallempty    ADR     R0,szbufferempty
2264                BL      pprint
2265                LDMFD   sp !,{R0-R4,PC}
2266.szrecallheader FNpp(   "Current contents of history buffer:"+cr$+bl$)
2267.szbufferempty  FNpp(   "The history buffer is empty."+cr$+bl$)
2268                FNalign
2269; Delete entry from current history buffer. For other instances using same
2270; buffer, adjust end and maybe cur
2271; /E R0 -> start of line to remove from current history buffer
2272.delhistent     STMFD   sp !,{R0-R4,R14}
2273                MOV     R1,R0
2274                LDRB    R14,[R1],#1
2275                CMP     R14,#13
2276                LDMLEFD sp !,{R0-R4,PC}
2277                MOV     R3,R0             ; Preserve for later
2278.delhistentlp   LDRB    R14,[R1],#1
2279                CMP     R14,#13
2280                BGT     delhistentlp
2281                STRLTB  R14,[R0,#-1]
2282.delhistentmvlp LDRGEB  R14,[R1],#1       ; !HACK! what if we delete last
2283                STRGEB  R14,[R0],#1       ; line?  Where does cur point?
2284                CMPGE   R14,#13
2285                BGE     delhistentmvlp
2286                LDR     R14,[R12,#head]
2287                SUB     R1,R1,R0          ; Length of line removed
2288                LDR     R4,[R9,#buf]
2289                STR     R0,[R9,#end]      ; For client buffers
2290                TEQ     R14,#0
2291                LDMEQFD sp !,{R0-R4,PC}   ; Only happens for client buffers
2292.delhistentlp2  LDR     R2,[R14,#buf]
2293                TEQ     R2,R4
2294                BNE     notsamebuffer
2295                STR     R0,[R14,#end]
2296                LDR     R2,[R14,#cur]
2297                CMN     R2,#-(-1)         ; If at bottom, don't adjust
2298                BEQ     notsamebuffer
2299                CMP     R2,R3             ; If deleted line was before this
2300                SUBHI   R2,R2,R1          ; instance's cur, move cur back so
2301                STRHI   R2,[R14,#cur]     ; it still points to same line
2302                                          ; (NB cur=0 is never changed)
2303                                          ; Also, if cur was the deleted line
2304                                          ; then it will now point to the
2305                                          ; next line (!HACK! if we delete
2306                                          ; last line and it's cur elsewhere
2307                                          ; ...?)
2308.notsamebuffer  LDR     R14,[R14,#next]
2309                TEQ     R14,#0
2310                BNE     delhistentlp2
2311                LDMFD   sp !,{R0-R4,PC}
2312; Add new history entry which is copied from linebuffer.
2313; If it duplicates an entry, then the old history entry is deleted
2314; otherwise the oldest history entries may be deleted to make room.
2315; Only exception - New entry is not added if no editing has been done
2316; on the line (i.e. it's up or down arrow and NOT RETURN)
2317; There are three cases here -
2318; (a) Line already in history => delete old copy and new will fit
2319; (b) Line isn't in history, but free space > line length
2320; (c) Line isn't in history, and free space <= line length
2321;     so we need to delete old lines until there's room
2322.addnewhistifmod
2323                TST     r8,#fEdit%        ; Don't add line if it's
2324                MOVEQ   PC,R14            ; unmodified
2325.addnewhist     STMFD   sp !,{R0-R5,R14}
2326                LDRB    R14,[R7]          ; See if line has leading space
2327                TEQ     R14,#32           ; and if so, check flags to see
2328                LDREQ   R14,[R12,#flags]  ; if we should store the line
2329                EOREQ   R14,R14,#f_NoLeadSpc
2330                TSTEQ   R14,#f_NoLeadSpc
2331                LDMEQFD sp !,{R0-R5,PC}
2332                ADD     R3,R7,R6          ; Find end of line, starting from
2333.anh_findeollp  LDRB    R14,[R3],#1       ; current position to save a bit
2334                CMP     R14,#32           ; of effort
2335                BGE     anh_findeollp     ; R3 = # bytes needed to store line
2336                SUB     R3,R3,R7          ;  = (length of line)+1
2337                LDR     R14,[R12,#minlen] ; Minimum length of line to store
2338                CMP     R3,R14
2339                LDRHI   R14,[R12,#maxlen] ; Maximum length of line to store
2340                SUBHI   R0,R3,#2          ; R0 = (length of line)-1
2341                CMPHI   R14,R0
2342                LDMLSFD sp !,{R0-R5,PC}   ; Don't add if below min/above max
2343                LDR     R14,[R9,#limit]
2344                LDR     R1,[R9,#buf]
2345                LDRB    R5,[R1],#1
2346                SUB     R14,R14,R1        ; R14 = (size of buffer) -1
2347                CMP     R3,R14            ; (allowing for inital CR in buf)
2348                LDMGTFD sp !,{R0-R5,R14}  ; If line won't fit, delete
2349                BGT     erasethisbuf      ; contents of buffer and exit
2350                TEQ     R5,#0             ; Is buffer empty?
2351                BEQ     anhwillfit        ; If so, case (b)
2352                LDR     R14,[R12,#flags]
2353                TST     R14,#f_KeepDupl   ; Check the "keep duplicates" flag
2354                BNE     noduplicate       ; If set, don't bother looking
2355.trynexthist    MOV     R2,R7
2356.anhcomparelp   LDRB    R14,[R2],#1
2357                LDRB    R0,[R1],#1
2358                CMP     R14,#32
2359                BLT     anhlineend
2360                CMP     R14,R0
2361                BEQ     anhcomparelp
2362.nomatch
2363.anhloop        CMP     R0,#13
2364                LDRGTB  R0,[R1],#1
2365                BGT     anhloop
2366                BEQ     trynexthist
2367.noduplicate
2368; found zero => reached end of buffer
2369; so we're in case (b) or (c) and we need R3 bytes free (= len of line +1)
2370                LDR     R2,[R9,#limit]    ; Set R2 to max value for end
2371                SUB     R2,R2,R3          ; which allows line to fit in
2372                LDR     R0,[R9,#buf]
2373                ADD     R0,R0,#1          ; Set up R0 for delhistent
2374.anhnukeloop    LDR     R14,[R9,#end]
2375                CMP     R14,R2
2376                BLO     anhwillfit
2377                BL      delhistent        ; If not enough space, remove
2378                B       anhnukeloop       ; first history entry and repeat
2379.anhwillfit     LDR     R1,[R9,#end]
2380                MOV     R14,#13
2381                STRB    R14,[R1,#-1]
2382                MOV     R2,R7
2383.anh_copylp     LDRB    R0,[R2],#1
2384                CMP     R0,#32
2385                STRGEB  R0,[R1],#1
2386                BGE     anh_copylp
2387                MOV     R14,#0
2388                STRB    R14,[R1],#1
2389                STR     R1,[R9,#end]      ; Needed for client buffers
2390                LDR     R0,[R9,#buf]      ; Update buffer end pointers
2391                LDR     R14,[R12,#head]
2392                TEQ     R14,#0
2393                LDMEQFD sp !,{R0-R5,PC}   ; Only happens for client buffers
2394.anh_adjbuflp   LDR     R2,[R14,#buf]
2395                TEQ     R0,R2
2396                STREQ   R1,[R14,#end]
2397                LDR     R14,[R14,#next]
2398                TEQ     R14,#0
2399                BNE     anh_adjbuflp
2400                LDMFD   sp !,{R0-R5,PC}
2401;
2402.anhlineend     CMP     R0,#13
2403                BGT     nomatch           ; Line in history is longer
2404; Found match, so in case (a)
2405; therefore, copy rest of buffer back by length of this line and add line
2406; to end of buffer (& there must be enough space)
2407                LDMLTFD sp !,{R0-R5,PC}   ; Line same as previous entry so
2408                SUB     R1,R1,#1          ; Run back to start of line
2409.anh_backlp     LDRB    R14,[R1,#-1]!
2410                CMP     R14,#32
2411                BGE     anh_backlp
2412                ADD     R0,R1,#1
2413                BL      delhistent
2414                B       anhwillfit
2415; Print a right-justified decimal value
2416; /E R0 = signed value to be printed, R1 = Field width (0 = no padding)
2417.outpadval      STMFD   sp !,{R0-R3,R14}
2418                MOV     R3,R1
2419                SUB     sp,sp,#12
2420                MOV     R1,sp
2421                MOV     R2,#12
2422                SWI     "XOS_ConvertInteger4" ; /X R0 = R1 on entry
2423                BVS     outpadvalerr      ; Just in case...
2424                SUB     R2,R1,R0          ; Length of result
2425                SUBS    R3,R3,R2
2426.outpadvallp    SWIGT   XOS_WriteI+ASC" "
2427                SUBGTS  R3,R3,#1
2428                BGT     outpadvallp
2429                SUB     R0,R1,R2          ; R0 = R1 - (R1-R0_orig) = R0_orig
2430                SWI     XOS_Write0        ; (in case SWI error corrupts R0)
2431.outpadvalerr   ADD     sp,sp,#12
2432                LDMFD   sp !,{R0-R3,PC}
2433; /E R0, bit0 -> 0 underline, 1 block, bit1 -> 0 flashing, 1 steady
2434.setcursorshape TST     R8,#fTaskwndw%
2435                MOVNE   PC,R14            ; Don't bother in taskwindow
2436                STMFD   sp !,{R0-R3,R14}
2437                MOV     R3,R0
2438                SWI     XOS_WriteI+23
2439                SWI     XOS_WriteI+0
2440                SWI     XOS_WriteI+10
2441                TST     R3,#%01           ; Test block/u-line
2442                MOVNE   R1,#7             ; Send extra zero
2443                BNE     vduzeros
2444                MVN     R0,#NOT(-1)       ; Current MODE
2445                MOV     R1,#0             ; Read ModeFlags
2446                SWI     "XOS_ReadModeVariable"
2447                TST     R2,#%10           ; Teletext MODE ?
2448                SWINE   XOS_WriteI+19     ; Yes, probably MODE 7
2449                SWIEQ   XOS_WriteI+7      ; Otherwise 'normal' MODE
2450                MOV     R1,#6
2451.vduzeros       ADR     R0,eight_zeros
2452                SWI     XOS_WriteN        ; Write out R1 zeros
2453                SWI     XOS_WriteI+23
2454                SWI     XOS_WriteI+1
2455                TST     R3,#%10           ; Test flashing/steady
2456                SWIEQ   XOS_WriteI+3
2457                SWINE   XOS_WriteI+2
2458                MOV     R1,#7
2459                ADR     R0,eight_zeros
2460                SWI     XOS_WriteN        ; Write out R1 zeros
2461                CMP     R0,R0
2462                LDMFD   sp !,{R0-R3,PC}
2463.eight_zeros    & 0:&    0          ; Only 7 actually needed
2464; /E R5 = private word pointer, R12 = contents of private word
2465; /X R12 -> newly allocated workspace if R12=0 on entry
2466.claimspace     TEQ     R12,#0            ; Have we already got workspace ?
2467                MOVNE   PC,R14            ; If yes, return
2468                STMFD   sp !,{R0-R4,R10,R14}
2469                MOV     R0,#sizeofheader  ; Lineeditor global data block
2470                BL      malloc
2471                MOVS    R12,R0
2472                BEQ     badworkspace      ; malloc returns 0 if claim failed
2473                MOV     R0,#256           ; Scratch block
2474                BL      malloc
2475                TEQ     R0,#0
2476                MOVEQ   R0,R12
2477                BEQ     claims_free      ; malloc returns 0 if claim failed
2478                STR     R0,[R12,#tmp256]
2479                MOV     R0,#129
2480                MOV     R1,#0
2481                MOV     R2,#&FF
2482                SWI     XOS_Byte
2483                STR     R1,[R12,#osver]   ; &A3 = RISC OS 3.00
2484                MOV     R0,#0
2485                STR     R0,[R12,#head]
2486                STR     R0,[R12,#lastth]
2487                STR     R0,[R12,#morebufs]
2488]
2489IF countclientbuf% THEN
2490[OPTA%
2491                STR     R0,[R12,#clbufcnt]
2492]
2493ENDIF
2494[OPTA%
2495                MOV     R1,#0
2496                MOV     R2,#0
2497                MOV     R3,#0
2498                MOV     R4,#&00000100     ; ins flash/under; over flash/block
2499                BL      le_setopts
2500;; This stuff was a fix which is now somewhere more appropriate
2501;                LDR     R0,[R12,#flags]
2502;                ANDS    R0,R0,#f_LocalHist; Local history?
2503; MOV R1,#0 ; (new) buffer size
2504;                BLEQ    newinst           ; EQ => R0=0
2505;                TEQ     R0,#0             ; If global history, create an
2506;                MOVEQ   R0,R12            ; instance for the command line
2507;                BLEQ    free              ; so that history isn't lost
2508;                BEQ     badworkspace      ; when all taskwindows are shut
2509                STR     R12,[R5]          ; Save workspc in priv. word
2510                LDMFD   sp !,{R0-R4,R10,PC}
2511.claims_free    BL      free
2512.badworkspace   LDMFD   sp !,{R0-R4,R10,R14}
2513.noroomerror    ADR     R0,noroom
2514                STMFD   sp !,{R14}
2515                SWI     "XOS_GenerateError"
2516                LDMFD   sp !,{PC}
2517;
2518; NB not necessarily in RMA nowadays
2519.noroom         & &101              ; No room in RMA error
2520                = "Couldn't allocate memory"+bl$
2521                FNalign
2522; Emit a beep - a subroutine so we can easily get beeps in taskwindows
2523; other than !Zap ones (which cope) later.
2524; Also, this preserves R0 and flags even if the SWI returns an error.
2525]
2526IF cleverbeep% THEN
2527[OPTA%
2528.beep           STMFD   sp !,{R0-R4,R14}
2529                MOV     R0,#213
2530                MOV     R1,#0
2531                MOV     R2,#255
2532                SWI     XOS_Byte
2533                MOV     R3,R2
2534                MOV     R4,R1
2535                MOV     R0,#211
2536                MOV     R1,#0
2537                MOV     R2,#255
2538                SWI     XOS_Byte
2539                MOV     R0,R1
2540                MOV     R1,R2,LSR #3 ; map &80-&f8 -> &10-&1f
2541                ADD     R1,R1,#&ff00
2542                ADD     R1,R1,#&00e1 ; map &10-&1f -> &fff1-0
2543                BIC     R1,R1,#&ff0000
2544                MOV     R2,R4
2545                SWI     "XSound_Control"
2546                LDMFD   sp !,{R0-R4,PC}
2547]
2548ELSE
2549[OPTA%
2550.beep           STMFD   sp !,{R0,R14}
2551                SWI     XOS_WriteI+7
2552                LDMFD   sp !,{R0,PC}
2553]
2554ENDIF
2555[OPTA%
2556.edstatus       STMFD   sp !,{R1,R9,R14}
2557                LDR     R12,[R12]
2558                LDR     R9,[R12,#head]
2559                TEQ     R9,#0
2560                LDMEQFD sp !,{R1,R9,PC}
2561                LDR     R14,[R12,#flags]
2562                TST     R14,#f_LocalHist  ; Local history?
2563                BEQ     call_edstbuf
2564                LDR     R1,[R12,#lastth]
2565.edstatusinstlp LDR     R14,[R9,#taskh]
2566                TEQ     R1,R14
2567                SWIEQ   XOS_WriteI+ASC"*" ; Mark current buffer
2568                BL      edstatusbuffer
2569                LDRVC   R9,[R9,#next]
2570                MOVVS   R9,#0
2571                TEQ     R9,#0
2572                BNE     edstatusinstlp
2573                LDMFD   sp !,{R1,R9,PC}
2574.call_edstbuf   BL      edstatusbuffer
2575                LDMFD   sp !,{R1,R9,PC}
2576; !HACK! give %age of buffer used, etc (eg maybe average length of line)
2577.edstatusbuffer STMFD   sp !,{R0-R3,R14}
2578                LDR     R3,[R9,#buf]
2579                ADR     R0,edstatushead
2580                BL      pprint
2581                LDR     R14,[R9,#limit]
2582                LDR     R1,[R9,#end]
2583                SUB     R1,R14,R1         ; Bytes free in hist buffer
2584                SUB     R2,R14,R3         ; Size of hist buffer
2585                BL      docolumns
2586                SWI     XOS_WriteS
2587                = "Lines"+bl$
2588                FNalign
2589                MOV     R0,#0
2590                MOV     R2,R3             ; For next pass of loop
2591.edstatclinelp
2592.edstatclinelp2 LDRB    R14,[R3],#1       ; Count the number of lines
2593                CMP     R14,#13
2594                BGT     edstatclinelp2
2595                ADDEQ   R0,R0,#1
2596                BEQ     edstatclinelp
2597                MOV     R1,#15
2598                BL      outpadval
2599                SWI     XOS_NewLine
2600                LDMFD   sp !,{R0-R3,PC}
2601.edstatushead  := tab$+tab$+"Used"+tab$+"Free"+hspc$+hspc$+hspc$
2602                = "Total"+cr$+"Size (bytes)"+bl$
2603                FNalign
2604; pretty print
2605; /E R0 -> string to print
2606.pprint         STMFD   sp !,{R0-R1,R14}
2607                ADR     R1,ppdict
2608;                ADR     R2,szSpecial
2609                SWI     "XOS_PrettyPrint"
2610                LDMFD   sp !,{R0-R1,PC}
2611.ppdict         :]
2612N%=0:REPEAT N%+=1:dummy=FNdict(D$(N%)):UNTIL N%=M%
2613[OPT A%
2614                = 0
2615                FNalign
2616.loadhistory    STMFD   sp !,{R7,R9,R14}
2617                MOV     R7,R0             ; Preserve filename
2618                LDR     R12,[R12]
2619                LDR     R9,[R12,#head]
2620                MOVS    R0,R9
2621                MOVEQ   R1,#0
2622                BLEQ    newinst           ; If no buffers, create one...
2623                MOVS    R9,R0             ; (was MOVEQS)
2624                BEQ     lh_nobufs
2625                ;
2626                LDR     R14,[R12,#flags]
2627                TST     R14,#f_LocalHist  ; Local history?
2628                BEQ     lh_global
2629                ;
2630                LDR     R1,[R12,#lastth]
2631.lh_findinstlp  LDR     R14,[R9,#taskh]
2632                TEQ     R1,R14
2633                LDRNE   R9,[R9,#next]
2634                TEQNE   R9,#0
2635                BNE     lh_findinstlp
2636                TEQ     R9,#0
2637                BEQ     lh_nobufs
2638                ;
2639.lh_global      MOV     R1,R7             ; Make R1->filename
2640                MOV     R0,#&4C           ; Generate errors, don't open dirs
2641                SWI     "XOS_Find"        ; Returns R0=handle
2642                LDMVSFD sp !,{R7,R9,PC}   ; return V flag
2643                MOV     R1,R0             ; Put file handle into R1
2644                ;
2645                LDR     R2,[R9,#buf]
2646                LDR     R7,[R12,#tmp256]
2647                MOV     R6,#0
2648.lh_linelp      MOV     R3,R7
2649                MOV     R5,#255
2650.lh_charlp      SWI     "XOS_BGet"
2651                BVS     lh_badswi
2652                BCS     lh_eof
2653                STRB    R0,[R3],#1
2654                CMP     R0,#32
2655                BLT     lh_addnewhist
2656                SUBS    R5,R5,#1
2657                BGE     lh_charlp
2658.lh_skipcharlp  SWI     "XOS_BGet"        ; Ignore to end of this line
2659                BVS     lh_badswi
2660                BCS     lh_done
2661                CMP     R0,#32
2662                BGE     lh_skipcharlp
2663                B       lh_linelp
2664.lh_addnewhist  BL      addnewhist
2665                B       lh_linelp
2666;
2667.lh_eof         MOV     R0,#0
2668                STRB    R0,[R3],#1
2669                BL      addnewhist
2670                ;
2671.lh_done        MOV     R0,#0
2672                SWI     "XOS_Find"        ; Close file
2673                LDMFD   sp !,{R7,R9,PC}   ; If no error R0 preserved, so R0=0
2674;
2675.lh_nobufs      LDMFD   sp !,{R7,R9,R14}
2676                B       noroomerror
2677;
2678.lh_badswi      MOV     R2,R0
2679                MOV     R0,#0
2680                SWI     "XOS_Find"        ; Try to close file
2681                MOV     R0,R2
2682                SWI     "XOS_GenerateError"
2683                LDMFD   sp !,{R7,R9,PC}
2684; if global history, no problem
2685; if local history, save history for last used buffer (tobedone!HACK!)
2686; if no last used buffer, save empty file
2687; /E R0->filename
2688; /X R0->error, if any ; R7-R11 preserved
2689.savehistory    MOV     R6,R14
2690                MOV     R1,R0
2691                MOV     R0,#&8C           ; Generate errors, don't open dirs
2692                SWI     "XOS_Find"        ; Returns R0=handle
2693                MOVVS   PC,R6
2694                ;
2695                MOV     R3,R0             ; Keep filehandle safe
2696                MOV     R0,#18
2697                MOV     R2,#&F00
2698                ORR     R2,R2,#&FF        ; &FFF => Text
2699                SWI     "XOS_File"        ; Set type to text
2700                MOV     R1,R3             ; Put file handle into R1
2701; Ignore errors in setting filetype in case it's something like "vdu;"
2702;                BVS     sh_badswi
2703                ;
2704                LDR     R12,[R12]
2705                LDR     R5,[R12,#head]
2706                TEQ     R5,#0
2707                BEQ     sh_nobufs
2708                ;
2709                LDR     R14,[R12,#flags]
2710                TST     R14,#f_LocalHist  ; Local history?
2711                BEQ     sh_global
2712                ;
2713                LDR     R2,[R12,#lastth]
2714.sh_findinstlp  LDR     R14,[R5,#taskh]
2715                TEQ     R2,R14
2716                LDRNE   R5,[R5,#next]
2717                TEQNE   R5,#0
2718                BNE     sh_findinstlp
2719                TEQ     R5,#0
2720                BEQ     sh_nobufs
2721                ;
2722.sh_global      LDR     R2,[R5,#buf]
2723                LDR     R3,[R5,#end]
2724                ADD     R2,R2,#1
2725                CMP     R2,R3
2726                BHS     sh_nobufs
2727                ;
2728.sh_lp          LDRB    R0,[R2],#1
2729                CMP     R0,#32
2730                MOVLT   R0,#10            ; End lines with '\n'
2731                SWI     "XOS_BPut"
2732                BVS     sh_badswi
2733                CMP     R2,R3
2734                BLO     sh_lp
2735                ;
2736.sh_nobufs      MOV     R0,#0
2737                SWI     "XOS_Find"        ; Close file
2738                MOV     PC,R6             ; If no error R0 preserved, so R0=0
2739                ;
2740.sh_badswi      MOV     R2,R0
2741                SWI     "XOS_Find"        ; Try to close file
2742                MOV     R0,R2
2743                SWI     "XOS_GenerateError"
2744                MOV     PC,R6
2745.canon          MOV     R1,R6
2746.canonlp        LDRB    R14,[R7,R1]
2747                TEQ     R14,#ASC" "
2748                TEQNE   R14,#ASC""""
2749                BEQ     canonout
2750                SUBS    R1,R1,#1
2751                BPL     canonlp
2752.canonout       ADD     R1,R1,#1
2753                ADD     R1,R1,R7
2754                MOV     R0,#37
2755                MOV     R2,#0
2756                MOV     R3,#0
2757                MOV     R4,#0
2758                MOV     R5,#0
2759                SWI     "XOS_FSControl"
2760                BVS     oops
2761                RSB     R5,R5,#1
2762                ADD     R0,R5,#18
2763                BL      malloc
2764                MOVS    R2,R0
2765                BEQ     oops
2766                MOV     R0,#37
2767                ADD     R2,R2,#18
2768                SWI     "XOS_FSControl"
2769                BVS     oops
2770                MOV     R0,#17
2771                MOV     R1,R2
2772                SWI     "XOS_File"       ; Check it's a directory (or image)
2773                MOV     R2,R1
2774                BVS     oops_free
2775                CMP     R0,#2
2776                BLO     oops_free
2777                SUB     R0,R2,#18
2778                ADR     R1,filer_opendir
2779                LDMIA   R1,{R1,R3-R5,R14}
2780                STMIA   R0,{R1,R3-R5}
2781                STRB    R14,[R0,#16]
2782                MOV     R14,R14,LSR #8
2783                STRB    R14,[R0,#17]
2784                SWI     "XOS_CLI"
2785                SUB     R0,R2,#18
2786                BL      free
2787                B       nextchar
2788;
2789.oops_free      SUB     R0,R2,#16
2790                BL      free
2791.oops           BL      beep
2792                B       nextchar
2793.filer_opendir := "%Filer_OpenDir -s "
2794FNassert ("P%-filer_opendir=18")
2795ALIGN
2796;.filer_closedir = "%Filer_CloseDir "
2797; /E
2798; R1 -> "path"
2799; R2 -> buffer to return matches
2800; R3 = max # to read [NOT next/prev]
2801; R4 = context count (or 0 initially)
2802; R5 = size of R2 buffer
2803; R6 -> wildcard "filename"
2804; /X
2805; R3 = # actually read
2806; R4 = updated context count or -ve for no more matches
2807; NB last read may return R3>0 and R4=-1
2808; flags preserved...
2809;
2810; [ VS => bad filename, etc
2811; may corrupt other flags (OS_GBPB gives R3=0 <=> CC) ]
2812;
2813.listfilenames  STMFD   sp !,{R0,R14}
2814FNtrace("listfilenames")
2815                LDR     R0,[R9,#compcontext]
2816                LDR     R0,[R0,#type]
2817                TEQ     R0,#typeSysvar
2818                LDMEQFD sp !,{R0,R14}
2819                BEQ     listsysvars
2820                TEQ     R0,#typeFS
2821                LDMEQFD sp !,{R0,R14}
2822                BEQ     listFS
2823                TEQ     R0,#typeCmd
2824                LDMEQFD sp !,{R0,R14}
2825                BEQ     listcmd
2826                ;
2827                MOV     R0,#9
2828;BL showregs
2829                SWI     XOS_GBPB
2830                TEQ     R0,#9
2831                MVNNE   R4,#NOT(-1)
2832                MOVNE   R3,#0
2833;                MVNVS   R4,#NOT(-1)
2834;                MOVVS   R3,#0
2835FNtrace("leaving listfilenames")
2836                LDMFD   sp !,{R0,PC}
2837.listfilenames2 STMFD   sp !,{R0,R14}
2838FNtrace("listfilenames2")
2839                LDR     R0,[R9,#compcontext]
2840                LDR     R0,[R0,#type]
2841                TEQ     R0,#typeSysvar
2842                LDMEQFD sp !,{R0,R14}
2843                BEQ     listsysvars2
2844                TEQ     R0,#typeFS
2845                LDMEQFD sp !,{R0,R14}
2846                BEQ     listFS2
2847                TEQ     R0,#typeCmd
2848                LDMEQFD sp !,{R0,R14}
2849                BEQ     listcmd2
2850                ;
2851                MOV     R0,#10            ; R0=12 is a RO3 enhancement
2852                SWI     XOS_GBPB
2853                TEQ     R0,#10
2854                MVNNE   R4,#NOT(-1)
2855                MOVNE   R3,#0
2856;                MVNVS   R4,#NOT(-1)
2857;                MOVVS   R3,#0
2858                LDMFD   sp !,{R0,PC}
2859.nextfilename   STMFD   sp !,{R0,R14}
2860                LDR     R0,[R9,#compcontext]
2861                LDR     R0,[R0,#type]
2862                TEQ     R0,#typeSysvar
2863                LDMEQFD sp !,{R0,R14}
2864                BEQ     nextsysvar
2865                TEQ     R0,#typeFS
2866                LDMEQFD sp !,{R0,R14}
2867                BEQ     nextFS
2868                TEQ     R0,#typeCmd
2869                LDMEQFD sp !,{R0,R14}
2870                BEQ     nextcmd
2871                ;
2872                MOV     R0,#9
2873.nextfilenamelp TEQ     R4,#0
2874                LDMMIFD sp !,{R0,PC}
2875                MOV     R3,#1             ; Read one at a time
2876                SWI     XOS_GBPB
2877                TEQ     R0,#9
2878                MVNNE   R4,#NOT(-1)
2879                MOVNE   R3,#0
2880                LDMNEFD sp !,{R0,PC}      ; Possibly bad dir name
2881                BCC     nextfilenamelp    ; Were no leafnames read?
2882;;                TEQ     R3,#0
2883;;                BEQ     nextfilenamelp    ; Were no leafnames read?
2884;                MVNVS   R4,#NOT(-1)
2885;                MOVVS   R3,#0
2886;                LDMVSFD sp !,{R0,PC}^     ; Possibly bad dir name
2887                LDMFD   sp !,{R0,PC}
2888.prevfilename   STMFD   sp !,{R0,R7,R14}
2889                LDR     R0,[R9,#compcontext]
2890                LDR     R0,[R0,#type]
2891                TEQ     R0,#typeSysvar
2892                LDMEQFD sp !,{R0,R7,R14}
2893                BEQ     prevsysvar
2894                TEQ     R0,#typeFS
2895                LDMEQFD sp !,{R0,R7,R14}
2896                BEQ     prevFS
2897                TEQ     R0,#typeCmd
2898                LDMEQFD sp !,{R0,R7,R14}
2899                BEQ     prevcmd
2900                ;
2901                MOV     R0,#9
2902                SUB     R7,R4,#1
2903.prevfilenamelp SUB     R7,R7,#1
2904                MOVS    R4,R7
2905                LDMMIFD sp !,{R0,R7,PC}
2906                MOV     R3,#1
2907                SWI     XOS_GBPB
2908                TEQ     R0,#9
2909                MVNNE   R4,#NOT(-1)
2910                MOVNE   R3,#0
2911                TEQ     R4,#0
2912                LDMMIFD sp !,{R0,R7,PC}   ; Possibly bad dir name
2913                BCC     prevfilenamelp    ; Were no leafnames read?
2914;;                TEQ     R3,#0
2915;;                BEQ     nextfilenamelp    ; Were no leafnames read?
2916;                MVNVS   R4,#NOT(-1)
2917;                MOVVS   R3,#0
2918;                LDMVSFD sp !,{R0,R7,PC}^  ; Possibly bad dir name
2919                LDMFD   sp !,{R0,R7,PC}
2920.nextsysvar
2921.listsysvars    STMFD   sp !,{R0-R2,R14}
2922FNtrace("nextsysvar/listsysvars")
2923; ignore R1 -> "path" ?!?
2924; ignore R3 and only return one match
2925                MOV     R1,R2
2926                MOV     R2,R5
2927                MOV     R0,R6
2928                MOV     R3,R4
2929                MOV     R4,#0
2930                SWI     "XOS_ReadVarVal"
2931                BVS     lsv_nope
2932                MOV     R4,R3
2933.listsysvarslp  LDRB    R14,[R3],#1
2934                STRB    R14,[R1],#1
2935                TEQ     R14,#0
2936                BNE     listsysvarslp
2937                MOV     R3,#1
2938                LDMFD   sp !,{R0-R2,PC}
2939;
2940.lsv_nope       MVN     R4,#NOT(-1)
2941                MOV     R3,#0
2942                LDMFD   sp !,{R0-R2,PC}
2943.listsysvars2   STMFD   sp !,{R0-R2,R14}
2944; ignore R1 -> "path" ?!?
2945; ignore R3 and only return one match
2946                ADD     R1,R2,#20 ;4
2947                SUB     R2,R5,#20
2948                MOV     R0,R6
2949                MOV     R3,R4
2950                MOV     R4,#0             ; Don't force to string...
2951                SWI     "XOS_ReadVarVal"
2952                BVS     lsv_nope
2953                STR     R4,[R1,#-4]       ; Store type of variable
2954                MOV     R2,R1             ; For after loop
2955                MOV     R4,R3
2956.listsysvars2lp LDRB    R14,[R3],#1
2957                STRB    R14,[R1],#1
2958                TEQ     R14,#0
2959                BNE     listsysvars2lp
2960                LDRB    R14,[R3]          ; Load type from OS data structure
2961                STR     R14,[R2,#-8]      ; to spot code variables
2962                MOV     R3,#1
2963                LDMFD   sp !,{R0-R2,PC}
2964.prevsysvar     STMFD   sp !,{R0-R2,R7,R8,R14}
2965; ignore R1 -> "path" ?!?
2966; ignore R3 and only return one match
2967                MOV     R7,R4 ; "r3_cur"
2968                MOV     R1,R2
2969                MOV     R0,R6
2970                MOV     R3,#0
2971.prevsysvarlp   MOV     R2,R5
2972                MOV     R4,#0
2973                MOV     R8,R3
2974                SWI     "XOS_ReadVarVal"
2975                BVS     psv_nope ; If var under finger is deleted or ...?
2976                TEQ     R3,R7
2977                BNE     prevsysvarlp
2978                MOVS    R4,R8
2979                BEQ     psv_nope
2980.psvcopylp      LDRB    R14,[R8],#1
2981                STRB    R14,[R1],#1
2982                TEQ     R14,#0
2983                BNE     psvcopylp
2984                MOV     R3,#1
2985                LDMFD   sp !,{R0-R2,R7,R8,PC}
2986;
2987.psv_nope       MVN     R4,#NOT(-1)
2988                MOV     R3,#0
2989                LDMFD   sp !,{R0-R2,R7,R8,PC}
2990.nextFS
2991.listFS         STMFD   sp !,{R0-R2,R14}
2992; ignore R1 -> "path" ?!?
2993; ignore R3 and only return one match
2994                MOV     R3,R5
2995                MOV     R0,#33
2996.lfslp          ADD     R1,R4,#1
2997                CMP     R1,#&100
2998                BHS     lfs_nope
2999                SWI     "XOS_FSControl"
3000                BVS     lfs_nope
3001                MOV     R4,R1
3002                LDRB    R14,[R2]
3003                TEQ     R14,#0
3004                BEQ     lfslp
3005                BL      wildmatch
3006                BNE     lfslp
3007                MOV     R3,#1
3008                LDMFD   sp !,{R0-R2,PC}
3009;
3010.lfs_nope       MVN     R4,#NOT(-1)
3011                MOV     R3,#0
3012                LDMFD   sp !,{R0-R2,PC}
3013.listFS2        STMFD   sp !,{R0-R2,R5,R14}
3014; ignore R1 -> "path" ?!?
3015; ignore R3 and only return one match
3016                ADD     R2,R2,#20 ;4
3017                SUB     R3,R5,#20 ;4
3018                MOV     R0,#33
3019.lfs2lp         ADD     R1,R4,#1
3020                CMP     R1,#&100
3021                BHS     lfs2_nope
3022                SWI     "XOS_FSControl"
3023                BVS     lfs2_nope
3024                MOV     R4,R1
3025                LDRB    R14,[R2]
3026                TEQ     R14,#0
3027                BEQ     lfs2lp
3028                BL      wildmatch
3029                BNE     lfs2lp
3030                MOV     R5,R2
3031                MOV     R0,#13
3032                SWI     "XOS_FSControl"   ; Returns R2 -> FS Info block
3033                LDR     R14,[R2,#&20]     ; Get FS Information Word
3034                STR     R14,[R5,#-4]      ; And note down as "type"
3035                MOV     R3,#1
3036                LDMFD   sp !,{R0-R2,R5,PC}
3037;
3038.lfs2_nope      MVN     R4,#NOT(-1)
3039                MOV     R3,#0
3040                LDMFD   sp !,{R0-R2,R5,PC}
3041.prevFS         STMFD   sp !,{R0-R2,R14}
3042; ignore R1 -> "path" ?!?
3043; ignore R3 and only return one match
3044                MOV     R3,R5
3045                MOV     R0,#33
3046.pfslp          SUBS    R1,R4,#1
3047                BLE     lfs_nope
3048                SWI     "XOS_FSControl"
3049                BVS     lfs_nope
3050                MOV     R4,R1
3051                LDRB    R14,[R2]
3052                TEQ     R14,#0
3053                BEQ     pfslp
3054                BL      wildmatch
3055                BNE     pfslp
3056                MOV     R3,#1
3057                LDMFD   sp !,{R0-R2,PC}
3058; R4 context value must be positive. Since here it's a word aligned pointer,
3059; we shift it right 2 bits before letting the outside world see it, then
3060; shift left when it gets passed back in
3061.nextcmd
3062.listcmd        STMFD   sp !,{R0-R2,R14}
3063; ignore R1 -> "path" ?!? !HACK! really?
3064; ignore R3 and only return one match
3065                MOVS    R4,R4,LSL#2
3066                LDREQ   R4,[R9,#root]
3067                LDRNE   R4,[R4,#tree_r%]
3068                TEQ     R4,#0
3069                BEQ     lcmd_nope
3070.lcmd_common    MOV     R0,R2
3071                LDR     R1,[R4,#tree_val%]
3072                ; !HACK! need to think about buffer size in R5
3073                BL      strcpy ; corrupts r0-r3
3074                MOV     R3,#1
3075                MOV     R4,R4,LSR#2
3076                LDMFD   sp !,{R0-R2,PC}
3077;
3078.lcmd_nope      MVN     R4,#NOT(-1)
3079                MOV     R3,#0
3080                LDMFD   sp !,{R0-R2,PC}
3081.listcmd2       STMFD   sp !,{R0-R2,R14}
3082; ignore R1 -> "path" ?!?
3083; ignore R3 and only return one match
3084                ADD     R2,R2,#20 ;4
3085                SUB     R3,R5,#20 ;4
3086                MOVS    R4,R4,LSL#2
3087                LDREQ   R4,[R9,#root]
3088                LDRNE   R4,[R4,#tree_r%]
3089                TEQ     R4,#0
3090                BEQ     lcmd_nope
3091                LDR     R1,[R4,#tree_type%]
3092                STR     R1,[R2,#-4] ; Note down as "type"
3093                B       lcmd_common
3094.prevcmd        STMFD   sp !,{R0-R2,R14}
3095; ignore R1 -> "path" ?!?
3096; ignore R3 and only return one match
3097                MOVS    R4,R4,LSL#2
3098                LDRNE   R4,[R4,#tree_l%]
3099                TEQNE   R4,#0
3100                BNE     lcmd_common
3101                B       lcmd_nope
3102; /E
3103; R2 -> String to match against
3104; R6 -> Wildmat-like pattern
3105;       ('*' matches 0 or more chars, '#' matches any single char)
3106; Match is case insensitive
3107;
3108; /X
3109; Z=1 (EQ) iff wildcard matches string
3110; may trash other flags
3111.wildmatch      STMFD   sp !,{r2,r0,r6,r14}
3112.wildmatchlp    LDRB    r0,[r6],#1        ; Character from pattern
3113;BL showregs
3114                TEQ     r0,#ASC"*"
3115                BEQ     wildmatchstar
3116                ;
3117                LDRB    r14,[r2],#1
3118                ;
3119                TST     r0,#&E0 ; EQ iff <32
3120                TSTEQ   r14,#&E0 ; EQ iff <32
3121                LDMEQFD sp !,{r2,r0,r6,PC} ; Return EQ
3122                ;
3123                CMP     r14,#ASC" "       ; Stop '#' matching string term.
3124                TEQGE   r0,#ASC"#"
3125                TEQNE   r0,r14
3126                BEQ     wildmatchlp
3127                ;
3128                EOR     r14,r0,r14
3129                TEQ     r14,#32
3130                LDMNEFD sp !,{r2,r0,r6,PC} ; Return NE
3131                BIC     r14,r0,#32
3132                CMP     r14,#ASC"A"
3133                RSBGES  r14,r14,#ASC"Z"
3134                BGE     wildmatchlp       ; Ignoring case, letters match
3135                LDMFD   sp !,{r2,r0,r6,PC} ; Return NE
3136                ;
3137.wildmatchstar                            ; Handle '*' wildcard
3138.wildmatstarlp  BL      wildmatch
3139                LDMEQFD sp !,{r2,r0,r6,PC} ; Return EQ
3140                ;
3141                LDRB    r14,[r2],#1
3142                CMP     r14,#ASC" "
3143                BGE     wildmatstarlp
3144                ;
3145                LDMFD   sp !,{r2,r0,r6,PC} ; Return NE
3146; Same as above, but only require wildmat pattern to match a prefix
3147; (i.e. the start of the string)
3148.wildmatchpfx   STMFD   sp !,{r2,r0,r6,r14}
3149.wildmatchpfxlp LDRB    r0,[r6],#1        ; Character from pattern
3150;BL showregs
3151                TEQ     r0,#ASC"*"
3152                BEQ     wildmatchpfxst
3153                ;
3154                LDRB    r14,[r2],#1
3155                ;
3156                TST     r0,#&E0 ; EQ iff <32
3157                LDMEQFD sp !,{r2,r0,r6,PC} ; Return EQ
3158                ;
3159                CMP     r14,#ASC" "       ; Stop '#' matching string term.
3160                TEQGE   r0,#ASC"#"
3161                TEQNE   r0,r14
3162                BEQ     wildmatchpfxlp
3163                ;
3164                EOR     r14,r0,r14
3165                TEQ     r14,#32
3166                LDMNEFD sp !,{r2,r0,r6,PC} ; Return NE
3167                BIC     r14,r0,#32
3168                CMP     r14,#ASC"A"
3169                RSBGES  r14,r14,#ASC"Z"
3170                BGE     wildmatchpfxlp    ; Ignoring case, letters match
3171                LDMFD   sp !,{r2,r0,r6,PC} ; Return NE
3172                ;
3173.wildmatchpfxst                           ; Handle '*' wildcard
3174.wildmatpfxstlp  BL      wildmatchpfx
3175                LDMEQFD sp !,{r2,r0,r6,PC} ; Return EQ
3176                ;
3177                LDRB    r14,[r2],#1
3178                CMP     r14,#ASC" "
3179                BGE     wildmatpfxstlp
3180                ;
3181                LDMFD   sp !,{r2,r0,r6,PC} ; Return NE
3182.complete4dos   STMFD   sp !,{R2-R7,R14}
3183                MOV     R6,R0             ; Wildcarded filename
3184                LDR     R2,[R9,#gbpbbuf]  ; Buffer to store filename
3185                MOV     R5,#bufsize%      ; Buffer size for results
3186                LDR     R0,[R9,#compcontext]
3187                LDR     R4,[R0,#context]
3188                TEQ     R4,#0
3189                MOVMI   R4,#0
3190                BL      afilename
3191                TEQ     R4,#0
3192                MOVMI   R1,#0
3193                STRPL   R4,[R0,#context]
3194                MOVPL   R0,R2
3195                MOVPL   R1,#1
3196                LDMFD   sp !,{R2-R7,PC}
3197                ;
3198.c4d_nomatch    MOV     R1,#0             ; Values
3199                LDMFD   sp !,{R2-R7,PC}
3200.afilename      TST     R8,#fCompRev      ; Scrolling back thru' completions?
3201                BEQ     nextfilename
3202                B       prevfilename
3203; /E R0 -> wildcarded filename (null-terminated) (ie ends ASC II 42 0)
3204;    R1 -> directory name (null-terminated)
3205; /X R0 -> buffer (maxlen% bytes) for return of (possibly partial) match
3206;    R1 =  # files matching spec (so 1=exact, 0=no match)
3207; in routine,   R7 = # files matching spec so far
3208;               R4,R6 only used by OS_GBPB
3209.completebuffer STMFD   sp !,{R1-R7,R14}  ; NB R1 is hoiked from stack
3210FNtrace("completebuffer")
3211                BL      caselessteq_init
3212                MOV     R6,R0             ; Wildcarded filename
3213                MOV     R7,#0             ; No files yet
3214                MOV     R4,#0             ; Reading position
3215.nomoreleafnms  CMP     R4,#0             ; Any more filenames pending
3216                BMI     nomatchatall      ; for next OS_GBPB call ?
3217;                MOV     R0,#9
3218                LDR     R1,[sp]           ; Recover from stack
3219                LDR     R2,[R9,#gbpbbuf]  ; Buffer to store filenames
3220                MOV     R3,#255           ; Max entries to read (ie max poss)
3221                MOV     R5,#bufsize%      ; Buffer size for results
3222                BL      listfilenames
3223                TEQ     R3,#0
3224                BEQ     nomoreleafnms     ; Were no leafnames read?
3225                TEQ     R7,#0             ; Is this the first scan ?
3226                BNE     alreadygotone
3227                LDR     R5,[R9,#mtchbuf]  ; Yes, so copy first name into
3228.initialmatchlp LDRB    R0,[R2],#1        ; match buffer
3229                STRB    R0,[R5],#1
3230                TEQ     R0,#0
3231                BNE     initialmatchlp    ; Should drop through if R0=0
3232; R0 should be zero at this point, so we fall through the findzerolp loop
3233.alreadyshort   ADD     R7,R7,#1          ; Success so far, so adjust
3234                SUBS    R3,R3,#1          ; counters and skip to last scan
3235                BEQ     nomoreleafnms     ; check if all names compared
3236;!HACK! This is a tad kludgy
3237.findzerolp     TEQ     R0,#0             ; Find null-terminator of current
3238                LDRNEB  R0,[R2],#1        ; filename ready for next compare
3239                BNE     findzerolp
3240.alreadygotone  LDR     R5,[R9,#mtchbuf]
3241.leafmatchlp    LDRB    R0,[R2],#1        ; Compare next name with current
3242                LDRB    R1,[R5],#1        ; match
3243                TEQ     R1,#0             ; Give up if new name is longer
3244                BEQ     alreadyshort
3245                BL      caselessteq       ; Corrupts r1
3246                BEQ     leafmatchlp       ; Keep looping if next char same
3247                MOV     R1,#0             ; (Possibly) truncate current match
3248                STRB    R1,[R5,#-1]!
3249                LDR     R14,[R9,#mtchbuf]
3250                TEQ     R5,R14            ; If all chars different, there's
3251                BNE     alreadyshort      ; no partial match
3252                MOV     R7,#0
3253.nomatchatall   LDR     R0,[R9,#mtchbuf]  ; No, so return appropriate
3254                MOV     R1,R7             ; values
3255                ADD     sp,sp,#4          ; Lose stacked R1
3256                LDMFD   sp !,{R2-R7,PC}
3257; /E R0 -> wildcarded filename (null-terminated) (ie ends ASC II 42 0)
3258;    R1 -> directory name (null-terminated)
3259; in routine,   R7 = # files matching spec so far
3260;               R4,R6 only used by OS_GBPB
3261.showcompletions
3262                STMFD   sp !,{R0-R7,R14}  ; NB R1 is hoiked from stack
3263                BL      prelist           ; Call for setting colours, etc
3264                MOV     R6,R0             ; Wildcarded filename
3265                MOV     R7,#0             ; No files yet
3266                MOV     R4,#0             ; Reading position
3267.Snomoreleafnms CMP     R4,#0             ; Any more filenames pending
3268                BMI     Snomatchatall     ; for next OS_GBPB call ?
3269;
3270                MOV     R0,#10            ; R0=12 is a RO3 enhancement
3271                LDR     R1,[sp,#4]        ; Recover from stack
3272                LDR     R2,[R9,#gbpbbuf]  ; Buffer to store filenames
3273                MOV     R3,#255           ; Max entries to read (ie max poss)
3274                MOV     R5,#bufsize%      ; Buffer size for results
3275                BL      listfilenames2
3276                TEQ     R3,#0
3277                BEQ     Snomoreleafnms    ; Were no leafnames read?
3278.Sprintlp       SWI     XOS_NewLine
3279;
3280                ADD     R2,R2,#20+3       ; Word align and skip
3281;                ADD     R2,R2,#24+3
3282                BIC     R2,R2,#%11        ; to leafname
3283;
3284                MOV     R1,R2             ; Note pointer to get at type info
3285.Sprintlp2      LDRB    R0,[R2],#1        ; match buffer
3286                TEQ     R0,#0
3287                SWINE   XOS_WriteC
3288                BNE     Sprintlp2
3289                ;
3290                ; !HACK! only set colours if there is a type...
3291                BL      listtype          ; Call for setting colours, etc
3292                LDR     R0,[R9,#compcontext]
3293                LDR     R0,[R0,#type]
3294                TEQ     R0,#typeFile
3295                BLEQ    sc_flagsFile
3296                TEQ     R0,#typeSysvar
3297                BLEQ    sc_flagsSysvar
3298                TEQ     R0,#typeFS
3299                BLEQ    sc_flagsFS
3300                TEQ     R0,#typeCmd
3301                BLEQ    sc_flagsCmd
3302                SWI     "OS_ReadEscapeState"
3303                BCS     Sprint_escape
3304                ; !HACK! only set colours if there is a type...
3305                BL      prelist           ; Call for setting colours, etc
3306                ADD     R7,R7,#1          ; Add to match count
3307                SUBS    R3,R3,#1          ; Are there anymore matches in
3308                BNE     Sprintlp          ; the buffer?
3309                B       Snomoreleafnms
3310.Sprint_escape  MOV     R0,#126
3311                SWI     "XOS_Byte"
3312                LDMFD   sp !,{R0-R7,PC} ; !HACK!
3313;
3314.Snomatchatall  BL      postlist          ; Call for setting colours, etc
3315                TEQ     R7,#0
3316                BNE     Snomatch32
3317                BL      beep
3318                LDMFD   sp !,{R0-R7,PC}
3319.Snomatch32     SWI     XOS_NewLine
3320                LDMFD   sp !,{R0-R7,R14}  ; Need "real" R6,R7 for redrawline
3321                B       prompt_and_line
3322;/E R1 -> start of leaf (flags before)
3323.sc_flagsFile   STMFD   sp !,{R0,R5,R14}
3324                LDR     R5,[R1,#-4]       ; ObjType 2=>dir/app
3325                TEQ     R5,#2
3326                MOVEQ   R5,#&1000<<8
3327                LDRNE   R5,[R1,#-20]      ; Load Address
3328                ADDNES  R5,R5,#-&FFF00000 ; Check if top 3 nibbles are &FFF
3329                MVNLO   R5,#NOT(-1)       ; If not, it's untyped
3330                MOV     R5,R5,ASR#8       ; Shift down into position
3331;                LDR     R5,[R1,#-4]      ; FileType, 1000=>dir, 2000=>apps
3332                RSBS    R5,R5,#&1000      ; See what we have
3333                SWILE   XOS_WriteI+ASC"." ; If dir/app print trailing '.'
3334                TEQ     R5,#&1000-&FFE    ; Command
3335                TEQNE   R5,#&1000-&FFC    ; Utility
3336                TEQNE   R5,#&1000-&FFB    ; BASIC
3337                TEQNE   R5,#&1000-&FF8    ; Absolute
3338                TEQNE   R5,#&1000-&FEB    ; Obey
3339                SWIEQ   XOS_WriteI+ASC"*" ; If executable print trailing '*'
3340                LDMFD   sp !,{R0,R5,PC}
3341;/E R1 -> start of leaf (flags before)
3342.sc_flagsSysvar STMFD   sp !,{R0,R2,R3,R14}
3343                LDMDB   R1,{R2,R3}       ; Load type info
3344                TEQ     R3,#1
3345                TEQNE   R3,#2
3346                TEQNE   R2,#16
3347                SWIEQ   XOS_WriteI+ASC" "
3348                TEQ     R2,#16
3349                SWIEQ   XOS_WriteI+ASC"C" ; Code variable is 16
3350                TEQ     R3,#1
3351                SWIEQ   XOS_WriteI+ASC"n" ; Number is 1
3352                TEQ     R3,#2
3353                SWIEQ   XOS_WriteI+ASC"M" ; Macro is 2
3354                LDMFD   sp !,{R0,R2,R3,PC}
3355;/E R1 -> start of leaf (flags before)
3356.sc_flagsFS     STMFD   sp !,{R0,R14}
3357                LDR     R14,[R1,#-4]      ; FS Info word
3358                TST     R14,#1<<16        ; Read-only?
3359                SWINE   XOS_WriteI+ASC" "
3360                SWINE   XOS_WriteI+ASC"r" ; If read-only, add " r"
3361                LDMFD   sp !,{R0,PC}
3362;/E R1 -> start of leaf (flags before)
3363.sc_flagsCmd    STMFD   sp !,{R0,R14}
3364                SWI     XOS_WriteI+32
3365                LDR     R0,[R1,#-4]      ; CMD_xxx value
3366                ADR     r14,cmdtypetab-4
3367                LDR     r0,[r14,r0,LSL#2]
3368                ADD     r0,r0,r14
3369                SWI     XOS_Write0
3370                LDMFD   sp !,{R0,PC}
3371.cmdtypetab     & cmd_alias-(cmdtypetab-4)
3372                & cmd_command-(cmdtypetab-4)
3373                & cmd_fileobj-(cmdtypetab-4)
3374.cmd_alias:= "Alias"+CHR$0:FNalign
3375.cmd_command:= "Command"+CHR$0:FNalign
3376.cmd_fileobj:= "File/Object"+CHR$0
3377FNalign
3378; Mark Wooding contributed the basis for this, which saved me writing it ;)
3379; Writes the CLI$Prompt string or "*" if it can't find it or something
3380; /E -
3381; /X -
3382.display_prompt STMFD   sp !,{R0-R4,R14}  ; Save some registers
3383                ADR     R0,promptVar      ; Point to the variable name
3384                LDR     R1,[R12,#tmp256]  ; Use scratch block
3385                MOV     R2,#256           ; Assume the size
3386                MOV     R3,#0             ; Start search at beginning
3387                MOV     R4,#3             ; Expand to a string, please
3388                SWI     "XOS_ReadVarVal"  ; Read the value nicely
3389                ADRVS   R1,starPrompt     ; If failed, use standard `*'
3390                MOVVS   R2,#1             ; Which is one byte long
3391                MOV     R0,R1             ; Point to the output buffer
3392                MOV     R1,R2             ; And get the string length
3393                SWI     "XOS_WriteN"      ; Write so many characters
3394;                STRVS   R0,[sp,#0]        ; If error, store pointer
3395                BL      preedit           ; And set colour again
3396                LDMFD   sp !,{R0-R4,PC}   ; And return to caller
3397.promptVar     := "CLI$Prompt"+bl$
3398.starPrompt    := "*"               ; Default prompt
3399                FNalign
3400; /E R7 -> line buffer, R6 = Offset of cursor on line (0=start)
3401;    (R10 = Max length) - not used currently, R8 = flags, etc
3402; /X R6 updated appropriately
3403; Note The cursor is moved to the end of the leafname and any deletes done.
3404;      Characters of the match are inserted into the keyboard buffer. The
3405;      code is 'lazy' about this and will do the minimum number of deletes
3406;      and inserts possible. A beep is emitted if the filename cannot be
3407;      fully completed due to a non/non-exact match.
3408.completefnm    TST     R8,#fPasswd
3409                BICNE   R8,R8,#fTcsh OR fShowComp OR fCompRev
3410                MOVNE   PC,R14
3411                STMFD   sp !,{R0-R5,R14}
3412FNtrace("completefnm")
3413                SWI     "XHourglass_On"
3414                ;
3415                MOV     R0,#bufsize%+64   ; 64 bytes extra to allow for
3416                BL      malloc            ; CDFS bug (returns too much data)
3417                STR     R0,[R9,#gbpbbuf]
3418                TEQ     R0,#0
3419                MOVNE   R0,#maxlen%
3420                BLNE    malloc
3421                TEQ     R0,#0
3422                BEQ     cantexpand        ; Beep if we can't allocate buffers
3423                STR     R0,[R9,#mtchbuf]
3424                ;
3425                LDR     R0,[R9,#compcontext] ; Do we already have context
3426                TEQ     R0,#0             ; from previous 4DOS expansion?
3427                BNE     gotcontext
3428                ;
3429                MOV     R0,#sizeofcontext
3430                BL      malloc
3431                STR     R0,[R9,#compcontext]
3432                MOVS    R5,R0
3433                MOVNE   R0,#0
3434                STRNE   R0,[R5,#dirname]
3435                STRNE   R0,[R5,#wildfnm]
3436                MOVNE   R0,#maxpathlen%
3437                BLNE    malloc
3438                TEQ     R0,#0             ; (if R5=0, won't matter)
3439                STRNE   R0,[R5,#dirname]
3440                MOVNE   R0,#maxlen%
3441                BLNE    malloc
3442                TEQ     R0,#0             ; (similarly)
3443                BEQ     cantexpand        ; Beep if we can't allocate buffers
3444                STR     R0,[R5,#wildfnm]
3445                ;
3446                MVN     R0,#NOT(-1)
3447                STR     R0,[R5,#context]
3448                MOV     R0,#typeFile
3449                STR     R0,[R5,#type]     ; Assume file completion initially
3450                ;
3451                BIC     R8,R8,#fAbbrev%   ; Assume not *Acc.Fred initially
3452                ADD     R4,R6,R7          ; Work backwards to find start
3453.stillbackinglp CMP     R4,R7             ; of full pathname
3454                BEQ     hitstartofline
3455                LDRB    R14,[R4,#-1]!
3456                TEQ     R14,#ASC" "
3457                TEQNE   R14,#ASC""""
3458                BNE     stillbackinglp
3459                ADD     R4,R4,#1          ; Adjust to point to start of path
3460; !HACK! What about a line which has leading spaces?
3461; currently it's never treated as a command
3462; It would be useful if "<stuff> *<partialcommand>" were interpreted as if
3463; the * before the partial command were a wildcard and not skipped
3464                B       gotstart
3465;
3466.hitstartofline LDRB    R14,[R4],#1
3467                TEQ     R14,#ASC"*"
3468                BNE     nostars
3469                LDR     R0,[R9,#compcontext]
3470                MOV     R14,#typeCmd
3471                STR     R14,[R0,#type]
3472.skipstarslp    LDRB    R14,[R4],#1
3473                TEQ     R14,#ASC"*"
3474                BEQ     skipstarslp
3475.nostars        TEQ     R14,#ASC"@"
3476                TEQNE   R14,#ASC"$"
3477                TEQNE   R14,#ASC"&"
3478                TEQNE   R14,#ASC"^"
3479                TEQNE   R14,#ASC"%"
3480                TEQNE   R14,#ASC"\"
3481; !HACK! abandon completion if "|" found?  Skip "|"?
3482                ORRNE   R8,R8,#fAbbrev%   ; Might be *Acc.Fred case
3483                SUB     R4,R4,#1
3484                B       gotstart
3485                ;
3486.nomatchmade    LDR     R4,[R9,#compcontext]
3487                LDR     R4,[R4,#type]
3488                TEQ     R4,#typeFile
3489                BNE     cantexpand
3490                TST     R8,#fAbbrev%      ; Worth considering as *Acc.Fred?
3491                BEQ     cantexpand
3492; Look for '.' from start of line - don't need to explicitly skip leading
3493; stars - it's done as we look for the '.'
3494                BIC     R8,R8,#fAbbrev%   ; This is the line's last chance
3495                MOV     R4,R7             ; Try to find the dot that marks
3496.seekdotlp      LDRB    R14,[R4],#1       ; end of the abbreviated *-command
3497                TEQ     R14,#13
3498                BEQ     cantexpand        ; If no dot found, leave alone
3499                TEQ     R14,#ASC"."
3500                BNE     seekdotlp
3501.gotstart       MOV     R2,R4             ; Copy pointer to start of pathname
3502FNtrace("gotstart")
3503                ADD     R5,R6,R7          ; Now go forwards to find
3504.stillgoinglp   LDRB    R14,[R5],#1       ; the full pathname end
3505                BIC     R14,R14,#2        ; Look for double quotes
3506                CMP     R14,#32           ; or space or control
3507                BGT     stillgoinglp
3508                SUB     R5,R5,#1
3509                MOV     R1,R5
3510                MOV     R3,#ASC"<"
3511.backdirlp      LDRB    R0,[R5,#-1]!      ; Work back from end to...
3512; check for ASC"<" (but not with ">" after)
3513                TEQ     R0,R3
3514                BEQ     completesysvar
3515                CMP     R5,R2             ; ...find the separator between
3516                BLS     blankdir          ; the pathname and leafname
3517                TEQ     R0,#ASC">"
3518                MOVEQ   R3,#256           ; 256 won't match any byte value
3519                TEQ     R0,#ASC"-"        ; This catches the "-adfs-foo"
3520                LDREQB  R14,[R2]          ; temporary FS case.
3521                TEQEQ   R14,#ASC"-"       ; NB '-' is OK in filenames, so
3522                TEQNE   R0,#ASC":"        ; check very carefully.
3523                ADDEQ   R5,R5,#1          ; Path should include a trailing
3524                TEQNE   R0,#ASC"."        ; '-' or colon but not trailing '.'
3525                BNE     backdirlp
3526                ;
3527                SUB     R14,R5,R4         ; Can't expand if
3528                CMP     R14,#maxpathlen%  ; (R5-R4)>=maxpathlen%
3529                BGE     cantexpand
3530                LDR     R3,[R9,#compcontext]
3531                LDR     R3,[R3,#dirname]  ; Point to pathname buffer
3532.copytofullbflp LDRB    R14,[R4],#1       ; Copy pathname into buffer
3533                STRB    R14,[R3],#1
3534                CMP     R4,R5
3535                BLT     copytofullbflp
3536                CMP     R0,#ASC"."        ; Adjust if . was separator
3537                ADDEQ   R5,R5,#1          ; (leave out from pathname _and_
3538                MOVEQ   R4,R5             ; leafname)
3539                B       notblankskip
3540;
3541.completesysvar
3542                LDR     R4,[R9,#compcontext]
3543                MOV     R14,#typeSysvar
3544                STR     R14,[R4,#type]
3545                ADD     R5,R5,#1
3546                MOV     R4,R5
3547                B       merge
3548;
3549.blankdir       MOVLT   R5,R2             ; Catch "foo." and ""
3550                LDRB    R14,[R2]
3551                TEQ     R14,#ASC"-"       ; Check for FS completion
3552                ADDEQ   R5,R5,#1
3553                LDR     R3,[R9,#compcontext]
3554                MOVEQ   R14,#typeFS
3555                STREQ   R14,[R3,#type]
3556                LDR     R3,[R3,#dirname]  ; Point to pathname buffer
3557                MOV     R4,R5
3558.notblankskip   MOV     R0,#0             ; Truncating pathname
3559                STRB    R0,[R3]
3560.merge
3561                TST     R8,#fTcsh         ; tcsh style completion?
3562                LDREQ   R14,[R9,#compcontext]
3563                LDREQ   R14,[R14,#context]; If not, then 4DOS - see if
3564                TSTEQ   R14,#1<<31        ; we're already doing it...
3565                BEQ     c4d_already
3566                LDR     R3,[R9,#compcontext]
3567                LDR     R3,[R3,#wildfnm]
3568                ADD     R2,R3,#maxlen%-1
3569.copywildfnmlp  CMP     R4,R1
3570                BGE     allcopied
3571                LDRB    R0,[R4],#1
3572                STRB    R0,[R3],#1
3573                CMP     R3,R2
3574                BNE     copywildfnmlp     ; Branch if leafname not too long
3575.cantexpand     BLEQ    beep              ; Beep because no unique match
3576                B       compfreebufxit
3577                ;
3578.allcopied      CMP     R0,#ASC"*"        ; Add a * to the end of leafname
3579                MOVNE   R0,#ASC"*"        ; if it doesn't already have one
3580                STRNEB  R0,[R3],#1
3581                MOV     R0,#0             ; Terminate the leafname
3582                STRB    R0,[R3]
3583;                SUB     R0,R2,#maxlen%-1  ; So r0 -> leafname
3584;
3585                LDR     r0,[r9,#compcontext]
3586                LDR     r3,[r0,#type]
3587                TEQ     r3,#typeCmd
3588                BLEQ    command_completion
3589;
3590.c4d_already    LDR     R3,[R9,#compcontext]
3591                STR     R5,[R3,#match_s]
3592                STR     R1,[R3,#match_e]
3593.gotcontext     LDR     R3,[R9,#compcontext]
3594                LDR     R0,[R3,#wildfnm]  ; R0 -> wildcarded leafname
3595                LDR     R1,[R3,#dirname]  ; R1 -> pathname
3596;BL showregs
3597                TST     R8,#fTcsh
3598                BEQ     not_tcsh
3599                BL      completebuffer    ; Returns r1 = #matches
3600FNtrace("returned from completebuffer")
3601                CMP     R1,#1
3602                BEQ     erkerkerk
3603                BL      beep              ; Match wasn't unique, so beep
3604                TST     R8,#fShowComp
3605                BEQ     erkerkerk
3606                STMFD   sp !,{r0,r1}
3607                LDR     R1,[R9,#compcontext]
3608                LDR     R0,[R1,#wildfnm]  ; R0 -> wildcarded leafname
3609                LDR     R1,[R1,#dirname]  ; R1 -> pathname
3610                BL      showcompletions
3611                LDMFD   sp !,{r0,r1}
3612                B       erkerkerk
3613;
3614.not_tcsh       TST     R8,#fShowComp
3615                BNE     go_showcompletions
3616                BL      complete4dos      ; Returns fMatchFound
3617                CMP     R1,#1
3618                BMI     nomatchmade       ; R1=0? => No match at all
3619                BLNE    beep              ; Match wasn't unique, so beep
3620.erkerkerk      CMP     R1,#1
3621                BMI     nomatchmade       ; R1=0? => No match at all
3622                MOVNE   R1,#0
3623                BLEQ    checkfordir       ; Returns R1=char to append or 0
3624                TST     R8,#fTcsh
3625                ORREQ   r8,r8,#fKeep4D    ; Preserve things for 4DOS matching
3626                LDR     R3,[R9,#compcontext]
3627;BL showregs
3628                LDR     R5,[R3,#match_s]
3629                LDR     R3,[R3,#match_e]
3630                BL      dothestringthing
3631FNtrace("donethestringthing")
3632                MOVS    R0,R1             ; Insert a trailing something if
3633                BLNE    printins          ; appropriate
3634FNtrace("done printins")
3635                ADD     R3,R7,R6
3636                LDR     R0,[R9,#compcontext]
3637                TEQ     R0,#0             ; printins might have nuked it
3638;BL showregs
3639                STRNE   R3,[R0,#match_e]
3640                BIC     r8,r8,#fKeep4D
3641.compfreebufxit FNtrace("compfreebufxit")
3642                LDR     R0,[R9,#gbpbbuf]  ; Free any allocated buffers
3643                BL      free
3644                STR     R0,[R9,#gbpbbuf]
3645                LDR     R0,[R9,#mtchbuf]
3646                BL      free
3647                STR     R0,[R9,#mtchbuf]
3648                LDR     R5,[R9,#compcontext]
3649                TEQ     R5,#0
3650                LDRNE   R0,[R5,#context]
3651                TEQNE   R0,#0
3652                BLMI    freecontext       ; Don't free context if 4DOS
3653                ;
3654                SWI     "XHourglass_Off"
3655FNtrace("leaving completefnm")
3656                LDMFD   sp !,{R0-R5,PC}
3657.go_showcompletions
3658                BL      showcompletions
3659                B       compfreebufxit
3660.freecontext    STMFD   sp !,{R0,R1,R14}
3661                LDR     R1,[R9,#compcontext]
3662                TEQ     R1,#0
3663                LDMEQFD sp !,{R0,R1,PC}
3664                ;
3665                LDR     R0,[R1,#dirname]
3666                TEQ     R0,#0
3667                BLNE    free
3668                LDR     R0,[R1,#wildfnm]
3669                TEQ     R0,#0
3670                BLNE    free
3671                MOV     R0,R1
3672                BL      free
3673                STR     R0,[R9,#compcontext]
3674                BL      free_cmdtree
3675                LDMFD   sp !,{R0,R1,PC}
3676; /E R0->leafname
3677; /X R1 = extra char to append (or 0 for none)
3678.checkfordir    STMFD   sp !,{R0,R2-R5,R14}
3679;                TST     R8,#fTcsh         ; Don't use with 4DOS completion
3680;                LDMEQFD sp !,{R0,R2-R5,PC}^ ; test duplicated for now
3681                LDR     R1,[R9,#compcontext]
3682                LDR     R14,[R1,#type]
3683                MOV     R1,#0
3684                TEQ     R14,#typeSysvar
3685                MOVEQ   R1,#ASC">"
3686                TEQ     R14,#typeFS
3687                MOVEQ   R1,#ASC"-"
3688                TEQ     R14,#typeFile
3689                LDMNEFD sp !,{R0,R2-R5,PC}
3690;                TST     R8,#fTcsh         ; Don't use with 4DOS completion
3691;                LDRNE   R4,[R12,#flags]
3692;                TSTNE   R4,#f_TrailDots   ; Trailing dots enabled?
3693                LDR     R4,[R12,#flags]
3694                TST     R4,#f_TrailDots   ; Trailing dots enabled?
3695                LDMEQFD sp !,{R0,R2-R5,PC}
3696                LDR     R4,[R9,#compcontext]
3697                LDR     R4,[R4,#dirname]  ; R4 -> pathname
3698                MOV     R1,R0             ; R1 -> leafname
3699                SUB     R0,R4,#1
3700; Stick a dot on the end if it's not empty and doesn't end with colon
3701.checkfordirlp  LDRB    R14,[R0,#1]!
3702                CMP     R14,#32
3703                BGE     checkfordirlp
3704                TEQ     R0,R4
3705                LDRNEB  R2,[R0,#-1]
3706                TEQNE   R2,#ASC":"
3707                MOVNE   R2,#ASC"."
3708                STRNEB  R2,[R0],#1
3709                STRNEB  R14,[R0],#1
3710                MOV     R0,#13            ; Find using path -> R4
3711                SWI     "XOS_File"
3712                TEQ     R0,#2             ; Directory found ?
3713                MOVEQ   R1,#ASC"."        ; If so append a "."
3714                MOVNE   R1,#0
3715                LDMFD   sp !,{R0,R2-R5,PC}
3716;/E
3717; R0 -> string to insert <nul terminated or something>
3718; R3 -> end of source string
3719; R5 -> to start of source string
3720; (R6=cursor position)
3721; (R7->linebuffer)
3722;   xxxxxxSSSSSSSyyyyyy
3723;R7>   R5>    R3>
3724;        R7+R6>
3725.dothestringthing
3726                STMFD   sp !,{R0,R2-R3,R5,R14}
3727                MOV     R2,R0
3728                SUB     R6,R3,R6          ; # chars cursor is from pathend
3729                SUB     R6,R6,R7
3730.compmvrightlp  SUBS    R6,R6,#1
3731                SWIPL   XOS_WriteI+9
3732                BPL     compmvrightlp
3733                SUB     R6,R3,R7          ; Need normal R6 for suckuptail
3734.lazyloop       LDRB    R0,[R2],#1 ; !HACK! for extra laziness, overtype too
3735                CMP     R5,R3             ; Redraw as little as possible
3736                BGE     addfullname       ; No need to delete any chars
3737                LDRB    R14,[R5],#1
3738                TEQ     R0,R14
3739                BEQ     lazyloop
3740                SUB     R5,R5,#1
3741                SUB     R3,R3,R5          ; Partial name width
3742                MOV     R5,R0
3743.compdelleftlp  SUBS    R3,R3,#1
3744                BMI     go_addfullname
3745                SWI     XOS_WriteI+127
3746                SUB     R6,R6,#1
3747                BL      suckuptail
3748                B       compdelleftlp
3749.go_addfullname MOV     R0,R5
3750.addfullname
3751.addfullnamelp  TEQ     R0,#0
3752                LDMEQFD sp !,{R0,R2-R3,R5,PC}
3753                BL      printins          ; Pretend character was typed
3754                LDRB    R0,[R2],#1        ; Insert full name
3755                B       addfullnamelp
3756;;;;;;;;;;;;;;;;;;;; command completion code ;;;;;;;;;;;;;;;;;;;;
3757;/E r0 -> completion context structure, r9 -> instance block
3758.command_completion
3759                STMFD   r13!,{r0-r8,r14} ; !REGS!
3760                BL      free_cmdtree
3761; !HACK! incorporate next few lines elsewhere
3762;                LDRB    r14,[r0]
3763;                TEQ     r14,#ASC"|"       ; Check for comment
3764;                LDMEQFD r13!,{r0-r8,pc}^ ; !REGS!
3765;dirname -> directory bit (might be prefix; or prefix;dir or dir.ectory)
3766;wildfnm -> wildcarded leafname
3767                MOV     r8,r0
3768                LDR     r1,[r8,#dirname]
3769                LDRB    r14,[r1]
3770                TEQ     r14,#0
3771                LDREQ   r1,[r8,#wildfnm] ; no pfx so just use leafname
3772                BEQ     ccnopfx
3773                LDR     r0,[R12,#tmp256] ; # !HACK! 256 enough?
3774                BL      strcpy ; corupts r0-r3
3775                LDR     r0,[R12,#tmp256]
3776.ccskiplp       LDRB    r14,[r0],#1
3777                TEQ     r14,#0
3778                BNE     ccskiplp
3779                SUB     r0,r0,#1
3780                LDRB    r14,[r0,#-1]
3781                TEQ     r14,#ASC":"
3782                MOVNE   r14,#ASC"."
3783                STRNEB  r14,[r0],#1
3784                LDR     r1,[r8,#wildfnm]
3785                BL      strcpy ; corupts r0-r3
3786                LDR     r1,[R12,#tmp256]
3787.ccnopfx
3788                                          ; Check fs<colon> prefix by
3789                MOV     r0,#11            ; trying to set temporary FS
3790                SWI     "XOS_FSControl"   ; 11,A% TO ,A%,oldfs%,special%
3791                MOV     r0,r1
3792; <fs><colon><command>
3793;            ^r0
3794;
3795; <module><colon><command>
3796; ^r0
3797;
3798; <command>
3799; ^r0
3800                CMN     r2,#-(-1)         ; -1 means we didn't set an FS,
3801                BNE     cmdcomp_isfs      ; so SWI had no effect
3802; !HACK! maybe check first char is A-Z a-z 0-9 or _ or ! or a few others
3803.cmdcomplp2     LDRB    r14,[r1],#1
3804                CMP     r14,#ASC":"
3805                CMPNE   r14,#ASC"."
3806                CMPNE   r14,#32
3807                BGT     cmdcomplp2
3808                CMP     r14,#ASC":"
3809                BNE     cmdcomp_notmod
3810                SUB     r1,r1,#1
3811                CMP     r1,r0
3812                BLE     cmdcomp_notmod
3813; Prefix given, so look in that module, if it exists
3814                MOV     r7,r1
3815                MOV     r1,r0 ; MOD%
3816                LDRB    r8,[r7]
3817                MOV     r14,#0
3818                STRB    r14,[r7]
3819                MOV     r0,#18
3820                SWI     "XOS_Module"      ; 18,MOD% TO ,,,pMod,,, ;F
3821                STRB    r8,[r7]
3822                ADD     r0,r7,#1
3823                MOVVC   r1,r3
3824                MOVVC   r2,#0
3825                BLVC    checkmod
3826.cmdcomp_dofilecomp
3827; !HACK!  PRINT"!!! Normal file completion !!!"
3828                B       cmdcomp_done
3829;
3830.cmdcomp_notmod
3831.cmdcomp_isfs
3832; Check for command in all modules
3833                BL      nomodprefix
3834; don't treat repeat.!r as a command, even though it could be
3835; it's probably filename completion that's intended
3836                MOV     r1,r0
3837.cmdcomplp3     LDRB    r14,[r1],#1
3838                CMP     r14,#ASC"."
3839                CMPNE   r14,#32
3840                BGT     cmdcomplp3
3841                CMP     r14,#ASC"."
3842                BEQ     cmdcomp_dofilecomp
3843                BL      checkrunpath      ; Now check along Run$Path
3844.cmdcomp_done   MOV     r0,#19            ; Restore current FS
3845                SWI     "XOS_FSControl"
3846                BL      flatten_cmd
3847;                BL      print_cmd
3848                LDMFD   r13!,{r0-r8,pc} ; !REGS!
3849.aliasbuf:= "Alias$"
3850.aliasins:= STRING$(250,CHR$0) ; !HACK! needs to be writable
3851FNalign
3852;/E r0 -> command
3853.checkalias     STMFD   r13!,{r0-r4,r14}
3854FNtrace("checkalias")
3855                MOV     r2,r0
3856                ADR     r1,aliasins+256
3857SUB r1,r1,#256
3858; " ""#$%&*,/ colon <>\^|" not allowed
3859.chkaliaslp     LDRB    r3,[r2],#1
3860                CMP     r3,#ASC"!"
3861                BEQ     chkaliaslpok
3862                CMP     r3,#38
3863                BLT     chkaliaslpout
3864                CMP     r3,#127
3865                BGE     chkaliaslpout
3866                TEQ     r3,#ASC","
3867;                TEQNE   r3,#ASC"*" ; "*" is a wildcard...
3868                TEQNE   r3,#ASC"/"
3869                TEQNE   r3,#ASC":"
3870                TEQNE   r3,#ASC"<"
3871                TEQNE   r3,#ASC">"
3872                TEQNE   r3,#ASC"\"
3873                TEQNE   r3,#ASC"^"
3874                TEQNE   r3,#ASC"|"
3875                BEQ     chkaliaslpout
3876.chkaliaslpok   STRB    r3,[r1],#1
3877                B       chkaliaslp
3878.chkaliaslpout
3879.chkaliaslp2    MOV     r14,#ASC"*" ; not needed if * on end !HACK!
3880                STRB    r14,[r1],#1 ; not needed if * on end !HACK!
3881                MOV     r14,#0
3882                STRB    r14,[r1],#1
3883                MOV     r3,#0
3884.chkaliaslp3    ADR     r0,aliasbuf
3885                MOV     r1,#0
3886                MOV     r2,#1<<31
3887                MOV     r4,#0
3888                SWI     "XOS_ReadVarVal"
3889;,A$,0,1<<31,R3,0 TO ,,N,R3,TYPE
3890                CMP     R2,#0
3891                BEQ     chkaliasnope
3892;                BPL     chkaliaslp3 ; !HACK! won't happen?
3893                ADD     r0,r3,#6
3894                MOV     r1,#CMD_alias
3895                BL      store_cmd
3896                B       chkaliaslp3
3897.chkaliasnope   ADR     r1,aliasins+256
3898                SUB r1,r1,#256
3899                MOV     r2,#0
3900.chkaliaslp5    LDRB    r14,[r1,#1]! ; truncate at previous dot, if any
3901                TEQ     r14,#ASC"."
3902                MOVEQ   r2,r1
3903                TEQ     r14,#0
3904                BNE     chkaliaslp5
3905                MOVS    r1,r2
3906                BNE     chkaliaslp2
3907                LDMFD   r13!,{r0-r4,PC}
3908.checkmodchain  STMFD   r13!,{r0-r8,r14}  ; Check modules in order
3909                MOV     r7,#0
3910                MOV     r8,r0
3911.checkmodchainlp
3912                MOV     r1,r7
3913                MOV     r0,#12
3914                MOV     r2,#0
3915                SWI     "XOS_Module"
3916                LDMVSFD r13!,{r0-r8,pc}
3917                ADD     r7,r7,#1
3918                MOV     r0,r8
3919                MOV     r1,r3
3920                MOV     r2,#0
3921                BL      checkmod
3922                B       checkmodchainlp
3923; check secondary and primary FS modules (eg ADFS, Filecore)
3924.checkfsmods    STMFD   r13!,{r0-r3,r14}
3925                MOV     r3,r0
3926                MOV     r0,#30
3927                SWI     "XOS_FSControl"
3928                MOVVC   r0,r3
3929                MOVVC   r2,#1
3930                BLVC    checkmod          ; 2nd FS RM
3931                MOV     r0,#20
3932                SWI     "XOS_FSControl"
3933                MOVVC   r0,r3
3934                MOVVC   r2,#1
3935                BLVC    checkmod          ; 1st FS RM
3936                LDMFD   r13!,{r0-r3,pc}
3937; /E R0 -> command, R1 -> module, r2 = fFS
3938.checkmod       STMFD   r13!, {r0-r2,r4-r6,r10,r14}
3939                MOVS    r10,r1
3940                LDRNE   r4,[r10,#24]
3941                TEQNE   r4,#0
3942                LDMEQFD r13!, {r0-r2,r4-r6,r10,pc}
3943                MOV     r5,r2
3944                ADD     R4,R10,R4          ; r4 -> module command table
3945                MOV     r6,r0             ; Pattern to match against
3946                SUB     R4,R4,#16
3947.chkmodlp       LDRB    R14,[R4,#16]!
3948                TEQ     R14,#0
3949                LDMEQFD r13!, {r0-r2,r4-r6,r10,pc}
3950                MOV     r2,r4             ; Command name
3951.chkmodlp2      LDRB    r14,[r4],#1        ; Find command info block
3952                TEQ     r14,#0
3953                BNE     chkmodlp2
3954                ADD     r4,r4,#3
3955                BIC     r4,r4,#3           ; Round up to 4 byte boundary
3956                LDR     r14,[r4]
3957                TEQ     r14,#0
3958                BEQ     chkmodlp           ; No code => not command
3959                LDR     r14,[r4,#4]
3960                TEQ     r5,r14,LSR#31 ; IF ((q!4)AND(1<<31))=0 EOR (fFS<>0)
3961                TSTEQ   r14,#1<<30        ; Is it a *Configure option?
3962                BNE     chkmodlp
3963; /E R2 -> String to match against, R6 -> Wildmat-like pattern
3964; /X Z=1 (EQ) iff wildcard matches string, may trash other flags
3965                BL      wildmatch ; now have trailing "*" so pfx not needed
3966;                BL      wildmatchpfx
3967                BNE     chkmodlp          ; Command doesn't match pattern
3968; !HACK! need to turn "." or whatever in command line into zero or whatever
3969; r8 -> first non matching char in command line
3970; r7 -> first non matching char in command in module
3971;                LDRB    r14,[r8]
3972;                CMP     r14,#32
3973;                BLE     chkmod_yep
3974;                TEQ     r14,#ASC"."
3975;                BNE     chkmod_notmatch
3976;                LDRB    r14,[r7]
3977;                TEQ     r14,#0
3978;                BEQ     chkmod_notmatch
3979;  REM match and has code ie is command
3980; LDR r0,[r10,#16]
3981; ADD r0,r0,r10
3982; r0 -> module name
3983;!HACK!    IF fFS X$+=" (as FS)"
3984                MOV     r0,r2
3985                MOV     r1,#CMD_command
3986                BL      store_cmd
3987                B       chkmodlp
3988.runpath:= "Run$Path"+CHR$0
3989.checkrunpath   STMFD   r13!,{r0-r8,r10-r11,r14}
3990FNtrace("checkrunpath")
3991;BL showregs
3992;SWI XOS_NewLine
3993;SWI XOS_Write0
3994;SWI XOS_NewLine
3995                MOV     r6,r0
3996;
3997;SYS "XOS_ReadVarVal","Run$Path",0,1<<31,0,0 TO ,,N,R3,TYPE
3998                ADR     r0,runpath
3999                MOV     r1,#0
4000                MOV     r2,#1<<31
4001                MOV     r3,#0
4002                MOV     r4,#0
4003                SWI     "XOS_ReadVarVal"
4004                CMP     r2,#0
4005                LDMPLFD r13!,{r0-r8,r10-r11,pc}
4006                RSBS    r2,r2,#0          ; MI <=> r2 is (and was) 1<<31
4007                MOVMI   r2,#256           ; so use 256 byte buffer
4008                ; need r2 bytes pointed to by r1
4009                MOV     r0,r2
4010                BL      malloc
4011                MOVS    r1,r0
4012                LDMEQFD r13!,{r0-r8,r10-r11,r14}
4013                BEQ     beep ; malloc failed, so beep and bail out !HACK!
4014                STMFD   r13!,{r1}
4015                ;
4016                ADR     r0,runpath
4017                MOV     r3,#0
4018                MOV     r4,#3
4019                SWI     "XOS_ReadVarVal"
4020                MOV     r14,#0
4021                STRB    r14,[r1,r2]
4022                ; R% r1 , P% r8 , Q% r10
4023                MOV     r8,r1
4024.chkrunpathlp                             ; Skip leading spaces
4025.chkrunpathlp2  LDRB    r14,[r8],#1
4026                TEQ     r14,#ASC" "
4027                BEQ     chkrunpathlp2
4028                SUB     r8,r8,#1
4029                SUB     r10,r8,#1
4030;  WHILE ?Q%<>ASC"," AND ?Q%>ASC" " / Q%+=1 / ENDWHILE
4031; skip r10 to "," or end of string
4032.chkrunpathlp3  LDRB    r14,[r10,#1]!
4033                CMP     r14,#ASC","
4034                CMPNE   r14,#ASC" "
4035                BGT     chkrunpathlp3
4036;
4037; G$ r11
4038                LDR     R11,[R9,#mtchbuf]  ; Slight abuse, but mtchbuf is filename sized
4039                MOV     r7,r11 ; F$="" if we chkrunpathskip
4040                CMP     r10,r8
4041                BLE     chkrunpathskip
4042;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4043                LDRB    r14,[r10,#-1]
4044                TEQ     r14,#ASC"."
4045                SUBEQ   r10,r10,#1
4046                TEQNE   r14,#ASC":"
4047                BEQ     chkrunpathskip
4048; end r7
4049                MOV     r7,r10
4050.chkrunpathlp4  TEQ     r8,r10
4051                BEQ     chkrunpath_x
4052                LDRB    r14,[r10,#-1]!
4053                TEQ     r14,#ASC"."
4054                TEQNE   r14,#ASC":"
4055                BNE     chkrunpathlp4
4056                ADD     r10,r10,#1
4057.chkrunpath_x
4058;REM G$ = Q% to end
4059; memcpy( r11, r10, r7 - r10 )
4060                SUB     r0,r7,r10
4061; !HACK! check r0 not too long
4062                ADD     r7,r0,r11 ; now "F$" r7
4063.chkrunpathlp4a SUBS    r0,r0,#1
4064                LDRGEB  r14,[r10,r0]
4065                STRGEB  r14,[r11,r0]
4066                BGT     chkrunpathlp4a
4067                LDRB    r14,[r10,#-1]
4068                TEQ     r14,#ASC"."
4069                SUBEQ   r10,r10,#1
4070.chkrunpathskip LDRB    r14,[r10]
4071                TEQ     r14,#0
4072                MOVNE   r0,#13
4073                STRNEB  r0,[r10],#1
4074                TEQ     r14,#ASC","
4075                BEQ     chkrunpath_y
4076.chkrunpathlp5  LDRB    r14,[r10],#1
4077                CMP     r14,#ASC","
4078                CMPNE   r14,#31
4079                BGT     chkrunpathlp5
4080.chkrunpath_y
4081; "F$" = r7, A% r6 (last use, except that we need to preserve for big loop)
4082                MOV     r0,r6
4083                MOV     r2,r7
4084FNtrace("chkrunpathlp6")
4085;BL showregs
4086.chkrunpathlp6  LDRB    r14,[r0],#1
4087                CMP     r14,#32
4088                STRGEB  r14,[r2],#1
4089                BGE     chkrunpathlp6
4090                MOV     r14,#ASC"*" ; not needed if * on end !HACK!
4091                STRB    r14,[r2],#1 ; not needed if * on end !HACK!
4092                MOV     r14,#0
4093                STRB    r14,[r2]
4094                MOV     r4,#0
4095.chkrunpathlp7
4096;   SYS "OS_GBPB",10,P%,D%,1,R4,2048,F$ TO ,,,R3,R4 ; flgs
4097                MOV     r0,#10
4098                MOV     r1,r8
4099                LDR     R2,[R9,#gbpbbuf]
4100                MOV     r5,#bufsize%
4101                MOV     r3,#255 ; much faster to read as many as we can per OS_GBPB
4102                STMFD   r13!,{r6}
4103                MOV     r6,r11
4104                SWI     "XOS_GBPB"
4105                LDMFD   r13!,{r6}
4106                ;   REM PRINTR3,R4,~flgs
4107                BVS     chkrunpathgbpberr
4108                CMP     R3,#0
4109                BLE     chkrunnoobj
4110.chkrunchkobj
4111; OK if object is
4112; * a file or an application directory/imagefile
4113; * RISC OS >3.5 and directory
4114; * appl
4115; !HACK! what about images (D%!16=3)?  Simes reckons same as files
4116; IF (D%!16 AND 1) OR (osver>=&A5 AND D%!16=2 AND "thatfile.!Run exists") OR ?(D%+20)=ASC"!" PROCout("File/object",FNs(D%+20+LEN G$),FNs(P%)+" '"+G$+"'")
4117;IF (D%!16 AND 1) OR (osver>=&A5 AND D%!16=2) OR ?(D%+20)=ASC"!"
4118;!HACK! in the directory/app case, ought to check for !Run
4119                LDRB    r14,[r2,#20]
4120                TEQ     r14,#ASC"!"
4121                BEQ     chkpathok
4122                LDR     r14,[r2,#16]
4123                TST     r14,#1
4124                BNE     chkpathok
4125                TEQ     r14,#2 ;!HACK! if ((type&1)==0) surely it must be 2 ???
4126                BNE     chkrunpathgbpbnotexec
4127                LDR     R14,[R12,#osver]
4128                CMP     r14,#&A5 ; osver RO 3.5 (I think)
4129                BLT     chkrunpathgbpbnotexec
4130.chkpathok
4131;PROCout("File/object",FNs(D%+20+LEN G$),FNs(P%)+" '"+G$+"'") !HACK! -> G$
4132                ADD     r0,r2,#20
4133                SUB     r14,r7,r11
4134                ADD     r0,r0,r14
4135                MOV     r1,#CMD_fileobj
4136                BL      store_cmd
4137.chkrunpathgbpbnotexec
4138                ADD     r2,r2,#20
4139.chkrunpathnextobjlp
4140                LDRB    r14,[r2],#1
4141                TEQ     r14,#0
4142                BNE     chkrunpathnextobjlp
4143                ADD     r2,r2,#3
4144                BIC     r2,r2,#3 ; Round up to next word boundary
4145                SUBS    r3,r3,#1
4146                BNE     chkrunchkobj
4147.chkrunnoobj    CMN     r4,#-(-1)
4148                BNE     chkrunpathlp7
4149.chkrunpathgbpberr
4150                MOV     r8,r10
4151                LDRB    r14,[r10,#-1]
4152                TEQ     r14,#0
4153                BNE     chkrunpathlp
4154                ;
4155                LDMFD   r13!,{r0}
4156                BL      free ; Release Run$Path buffer
4157                ;
4158                LDMFD   r13!,{r0-r8,r10-r11,pc}
4159.nomodprefix    STMFD   r13!,{r1-r2,r14}
4160  ; Check for aliases if not suppressed by '%'
4161                LDRB    r14,[r0]
4162                TEQ     r14,#ASC"%"
4163                ADDEQ   r0,r0,#1
4164                BLNE    checkalias
4165                LDR     r1,[r12,#pKernel] ; Check kernel first
4166                MOV     r2,#0
4167                TEQ     r1,#0
4168                BLNE    checkmod
4169                BL      checkmodchain
4170                BL      checkfsmods
4171                LDMFD   r13!,{r1-r2,pc}
4172]:tree_val%=8:tree_type%=12:tree_l%=0:tree_r%=4:[OPT A%
4173; /E r0 -> cmd name, r1 = type code
4174.store_cmd      STMFD   r13!,{r0-r3,r4-r6,r12,r14}
4175                MOV     r4,r0
4176;SWI XOS_WriteI+32
4177;SWI XOS_Write0
4178;SWI XOS_NewLine
4179                MOV     r5,r1
4180                ADD     r12,r9,#root
4181.store_cmdlp    LDR     r6,[r12]
4182                TEQ     r6,#0
4183                BEQ     store_cmd_new
4184                LDR     r1,[r6,#tree_val%]
4185                MOV     r0,r4
4186                BL      stricmp
4187                LDMEQFD r13!,{r0-r3,r4-r6,r12,pc} ; already got it
4188                ADDGT   r12,r6,#tree_r%
4189                ADDLT   r12,r6,#tree_l%
4190                B       store_cmdlp
4191;
4192.store_cmd_new  MOV     r0,#16+240 ; !HACK!
4193                BL      malloc
4194                TEQ     r0,#0
4195                LDMEQFD r13!,{r0-r3,r4-r6,r12,pc} ; aargh
4196                MOV     r1,#0
4197                MOV     r2,#0
4198                ADD     r3,r0,#16
4199                STMIA   r0,{r1,r2,r3,r5}
4200.scn_lp         LDRB    r14,[r4],#1
4201                STRB    r14,[r3],#1
4202                TEQ     r14,#0
4203                BNE     scn_lp
4204FNassert("tree_l%=0 AND tree_r%=4 AND tree_val%=8 AND tree_type%=12")
4205                STR     r0,[r12]
4206                LDMFD   r13!,{r0-r3,r4-r6,r12,pc}
4207; corrupts r1-r3, returns flags
4208.stricmp
4209 STMFD   r13!,{r4,r14}
4210 MOV     r2,r0
4211 MVN     r0,#NOT -1
4212 SWI     "XTerritory_UpperCaseTable"
4213 BVS     simple_stricmp
4214.stricmplp
4215 LDRB    r3,[r2],#1
4216 LDRB    r14,[r1],#1
4217 LDRB    r3,[r0,r3]
4218 LDRB    r14,[r0,r14]
4219 ORRS    r4,r3,r14 ; Test for end of both strings
4220 LDMEQFD r13!,{r4,pc} ; If both end together, return 0 (strings equal)
4221 SUBS    r4,r3,r14
4222 BEQ     stricmplp
4223 LDMFD   r13!,{r4,pc}
4224.simple_stricmp
4225.stricmplp
4226 LDRB    r3,[r2],#1
4227 LDRB    r14,[r1],#1
4228 ORRS    r0,r3,r14 ; Test for end of both strings
4229 BIC     r3,r3,#32 ; crude caselessness !HACK!
4230 BIC     r14,r14,#32
4231 LDMEQFD r13!,{r4,pc} ; If both end together, return 0 (strings equal)
4232 SUBS    r0,r3,r14
4233 BEQ     stricmplp
4234 LDMFD   r13!,{r4,pc}
4235; corrupts r0-r3, r0 return value not important
4236.strcpy
4237.strcpylp
4238 LDRB    r2,[r1],#1
4239 STRB    r2,[r0],#1
4240 TEQ     r2,#0
4241 BNE     strcpylp
4242 MOV     pc,r14
4243; On entry:
4244;  root -> O
4245;         / \
4246; tree_l V   V tree_r
4247;            B
4248;           / \
4249;   tree_l V   V tree_r
4250;
4251; On exit:
4252; root -> O <-> O ->
4253;           r l    r
4254.flatten_cmd    STMFD   r13!,{r0,r1,r14}
4255                LDR     r0,[R9,#root]
4256                MOV     r1,#0
4257                TEQ     r0,#0
4258                BLNE    fl_cmd_subtree ; corrupts r0,r1
4259                LDMFD   r13!,{r0,r1,pc}
4260; NB this routine corrupts r0,r1
4261; This is done as it may recurse a lot, and stack space is precious
4262; /E r0 -> node, r1 -> last node
4263.fl_cmd_subtree STMFD   r13!,{r12,r14}
4264                MOV     r12,r0
4265.fl_cmd_sublp   LDR     r0,[r12,#tree_l%]
4266                TEQ     r0,#0
4267                BLNE    fl_cmd_subtree
4268                TEQ     r1,#0
4269                STRNE   r1,[r12,#tree_l%] ; left most node already has l=0
4270                STRNE   r12,[r1,#tree_r%]
4271                STREQ   r12,[r9,#root]    ; root is now left-most node
4272                MOV     r1,r12
4273                LDR     r12,[r12,#tree_r%]
4274                TEQ     r12,#0
4275                BNE     fl_cmd_sublp
4276                LDMFD   r13!,{r12,pc}
4277.free_cmdtree   STMFD   r13!,{r0,r1,r14}
4278                LDR     r1,[R9,#root]
4279.free_cmdlp     MOVS    r0,r1
4280                LDRNE   r1,[r1,#tree_r%]
4281                STREQ   r0,[R9,#root]
4282                LDMEQFD r13!,{r0,r1,pc}
4283                BL      free
4284                B       free_cmdlp
4285;.print_cmd      STMFD   r13!,{r0,r12,r14}
4286;                LDR     r12,[r9,#root]
4287;                TEQ     r12,#0
4288;.pr_cmd_lp      LDRNE   r0,[r12,#tree_val%]
4289;                SWINE   XOS_Write0
4290;                SWINE   XOS_NewLine
4291;                LDRNE   r12,[r12,#tree_r%]
4292;                TEQNE   r12,#0
4293;                BNE     pr_cmd_lp
4294;                LDMFD   r13!,{r0,r12,pc}^
4295; Find Kernel Pseudo-Module
4296; Hacky, but works for RISC OS-s 2.0, 3.1, 3.5 and hopefully the rest
4297.kmodid:= "MODULE#"+CHR$0:FNalign
4298.findkmod       STMFD   r13!,{r0-r3,r14}
4299                MOV     r0,#19
4300                MOV     r1,#0
4301                MVN     r2,#0
4302                SWI     "XOS_Module" ; On exit, r3 -> module name
4303                MOV     r0,r3,LSR #20 ; round down to megabyte boundary
4304                MOV     r0,r0,LSL #20
4305                LDR     r1,kmodid
4306                LDR     r2,kmodid+4
4307                ORR     r3,r3,#1 ; so we don't get EQ
4308.findkmodlp     LDR     r14,[r0],#4
4309.kfalsealarm    CMP     r14,r1
4310                CMPNE   r0,r3
4311                BLO     findkmodlp
4312                BNE     knotfound ; relies on NE
4313                LDR     r14,[r0],#4
4314                TEQ     r14,r2
4315                BNE     kfalsealarm
4316.knotfound      MOVNE   r0,#0
4317                STR     r0,[r12,#pKernel]
4318                LDMFD   r13!,{r0-r3,pc}
4319;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4320.postlist
4321.preedit        STMFD   r13!,{r0-r4,R14}
4322                ADR     R0,prevar
4323.prepostjoin    LDR     R1,[R12,#tmp256]
4324                MOV     R2,#256
4325                MOV     R3,#0
4326                MOV     R4,#3
4327                SWI     "XOS_ReadVarVal"
4328                LDMVSFD r13!,{r0-r4,pc}
4329                MOV     R0,R1
4330                MOVS    R1,R2
4331                SWINE   XOS_WriteN
4332                LDMFD   r13!,{r0-r4,pc}
4333.postedit       STMFD   r13!,{r0-r4,R14}
4334                ADR     R0,postvar
4335                B       prepostjoin
4336.prelist        STMFD   r13!,{r0-r4,R14}
4337                ADR     R0,prelistvar
4338                B       prepostjoin
4339.listtype       STMFD   r13!,{r0-r4,R14}
4340                ADR     R0,listtypevar
4341                B       prepostjoin
4342.prevar        := "LineEditor$Edit":= 0
4343.postvar       := "LineEditor$Output":= 0
4344.prelistvar    := "LineEditor$List":= 0
4345.listtypevar   := "LineEditor$Type":= 0
4346                FNalign
4347; /E R0 -> buffer (b30=>echo char in R4,b31=>echo only chars entering buffer)
4348; !HACK! bit 31 ignored currently
4349;    R1 = Max length (NB may be >255),
4350;    R2,R3 = Min, Max ASC II values to be inserted in buffer
4351; /X R1 = Length of buffer read, excluding CR
4352.myreadlinev    STMFD   sp !,{R0,R2,R3,R4,R6-R11,R14} ; no PC any more
4353                TEQ     PC,PC
4354                BICNE   R7,R0,#%11<<30    ; Copy parameters to
4355                MOVEQ   R7,R0             ; where we want them
4356                MOV     R10,R1
4357                AND     R8,R3,#255
4358                ORR     R8,R8,R2,LSL#24   ; Shift loses high bits
4359                MOVNE   R0,R0,LSR#30
4360                MOVEQ   R0,R4,LSR#30
4361                AND     R4,R4,#255
4362                ORR     R8,R8,R0,LSL#(LN fPasswd / LN 2)
4363;                TST     R0,#1<<31         ; Echo only chars entering buffer?
4364;                ORRNE   R8,R8,#f<summat>  ; If so, set flag
4365                BL      readtaskhandle
4366                TEQ     R0,#0             ; Now R0=taskh/0 if not in taskwndw
4367                ORRNE   R8,R8,#fTaskwndw% ; Set taskwindow flag
4368                LDR     R9,[R12,#head]
4369.searchinstlp   TEQ     R9,#0
4370                BEQ     neednewinst
4371                LDR     R14,[R9,#taskh]
4372                TEQ     R14,R0
4373                LDRNE   R9,[R9,#next]
4374                BNE     searchinstlp
4375                B       foundinst
4376;
4377.neednewinst    MOV     R1,#0
4378                BL      newinst
4379                MOVS    R9,R0
4380                BEQ     cantcreateinst
4381                LDR     R0,[R9,#taskh]
4382                MOV     R1,#swichunk AND &FFFFF000
4383                ORR     R1,R1,#swichunk AND &00000FFF
4384                SWI     "XOS_ServiceCall"
4385                MOVVS   R1,#1
4386                TEQ     R1,#0
4387                MOVNE   R0,#0 ; default flags for taskwindow server
4388                ; !HACK! now store flags
4389                ; !HACK! flags for command line?
4390                ; !HACK! can we guess server?
4391.foundinst      BL      dogenericlineedit
4392                LDMFD   sp !,{R0,R2,R3,R4,R6-R11,R14,PC} ; don't pass on call
4393.cantcreateinst MOVS    R0,R9             ; One of the malloc-s failed
4394                BLNE    free              ; free _will_ ignore a NULL pointer
4395                BL      beep
4396                                          ; Pass onto next ReadLineV claimant
4397                LDMFD   sp !,{R0,R2,R3,R4,R6-R11,PC}
4398;;;                ADD     sp,sp,#4          ; Skip PC stored on stack
4399;;;                MOVS    PC,R14            ; Pass onto next ReadLineV claimant
4400.readtaskhandle STMFD   sp !,{R14}
4401                MOV     R0,#3             ; Read fDesktopActive (RO3+)
4402                SWI     XWimp_ReadSysInfo
4403                TEQ     R0,#0
4404                MOVNE   R0,#5             ; Read active task handle if in
4405                SWINE   XWimp_ReadSysInfo ; taskwindow (RO3+) (corrupts R1)
4406                LDMVCFD sp !,{pc}         ; (RO3+) we now have it, so return
4407                MOV     R0,#20
4408                MOV     R1,#0
4409                MOV     R2,#0
4410                STMFD   sp !,{r1,r2}      ; Build 5-word msg block on stack
4411                STMFD   sp !,{r0,r1,r2}   ; holding { 20, 0, 0, 0, 0 }
4412                MOV     R0,#19            ; Either RISC OS 2 or Arthur or
4413                MOV     R1,sp             ; the Wimp module is unplugged
4414                MVN     R2,#NOT(-1)       ; so try RO2 method to find taskh
4415                SWI     XWimp_SendMessage ; NB RO2 returns VS for ShellCLI
4416                MOVVS   R0,#0             ; 0 => Not in a taskwindow
4417                LDRVC   R0,[sp,#4]        ; Read task handle returned
4418                ADD     sp,sp,#20         ; Restore stack pointer
4419                LDMFD   sp !,{pc}
4420; \E as OS_ReadLine, but flag bits moved to R6 b0 b1; R5 = buffer ID
4421; \X as OS_ReadLine, except R2,R3 preserved
4422.ReadLine       STMFD   sp !,{R2-R11,R14}
4423                AND     R5,R5,#3
4424                MOV     R7,R0             ; Copy parameters to
4425                MOV     R10,R1            ; where we want them
4426                AND     R8,R3,#255
4427                ORR     R8,R8,R2,LSL#24   ; Shift loses high bits
4428                ORR     R8,R8,R5,LSL#(LN fPasswd / LN 2)
4429                MOV     R9,R6
4430                BL      validate_id
4431                BLVC    dogenericlineedit
4432                LDMFD   sp !,{R2-R11,PC}
4433; \E as for .dolineedit (except for fCopy bit in R8)
4434; \X as for OS_ReadLine, except R6-R11 may be corrupt
4435.dogenericlineedit
4436                STMFD   sp !,{R14}
4437                MOV     R11,#4            ; Store values of *FX 221-228
4438.ollylp         RSB     R0,R11,#225       ; Program FN keys to return
4439                MOV     R1,#2             ; extended codes ie zero
4440                MOV     R2,#0             ; byte followed by code
4441                SWI     XOS_Byte          ; NB Error corrupts R0
4442                AND     R1,R1,#&FF
4443                ORR     R3,R1,R3,LSL#8
4444                SUBS    R11,R11,#1
4445                STMEQFD sp !,{R3}         ; Save on the stack
4446                CMN     R11,#-(-4)
4447                BNE     ollylp
4448                MOV     R0,#219
4449                MOV     R1,#&8A
4450                MOV     R2,#0
4451                SWI     XOS_Byte          ; Set up TAB key WIMP style
4452                STMFD   sp !,{R1,R3}      ; Save on the stack
4453                MOV     R0,#4             ; Make cursor keys act as
4454                MOV     R1,#2             ; function keys
4455                SWI     XOS_Byte          ; Returns r1=old state, r2=?
4456                TEQ     R1,#0
4457                ORREQ   r8,r8,#fCopy%     ; COPYing is ok iff *FX4,0
4458                BL      preedit
4459                BL      dolineedit        ; Actually input a line!
4460                BL      postedit
4461                MOV     R0,#0
4462                STR     R0,[R9,#r7]       ; No line
4463                MOV     R0,#4
4464                SWI     XOS_Byte          ; Restore cursor keys
4465                LDMFD   sp !,{R1,R3}      ; Retrieve from stack
4466                MOV     R0,#219
4467                MOV     R2,#0
4468                SWI     XOS_Byte          ; Restore TAB key
4469                MOV     R11,#4
4470.ollylp2        ADD     R0,R11,#224       ; Restore FN key interprettns
4471                AND     R1,R3,#&FF
4472                MOV     R2,#0
4473                SWI     XOS_Byte          ; NB Error corrupts R0
4474                MOV     R3,R3,LSR #8
4475                SUBS    R11,R11,#1
4476                LDMEQFD sp !,{R3}
4477                CMN     R11,#-(-4)
4478                BNE     ollylp2
4479                MOV     R1,R6             ; Now R1=length of line
4480                MOV     R14,#0
4481                STR     R14,[R9,#cur]     ; Mark instance inactive
4482                TST     r8,#fEsc%         ; See if escape was pressed
4483                BEQ     notesc
4484                SUBS    R0,R0,#0          ; C=1, V=0
4485                LDMFD   sp !,{PC}
4486.notesc         ADDS    R0,R0,#0          ; C=0, V=0
4487                LDMFD   sp !,{PC}
4488; /E R0 = task handle or = 0 for not a taskwindow or = -1 for client buffer
4489;    R1 = buffer size (or 0 for default)
4490; /X R0 -> new instance or = 0 if couldn't create
4491.newinst        STMFD   sp !,{r1-r3,r6,r9,r14}
4492                MOVS    R3,R1
4493                LDREQ   R3,[R12,#bufsize]
4494                MOV     R1,R0
4495                MOV     R0,#sizeofinst    ; Create new instance for taskh R0
4496                BL      malloc            ; (either new taskwindow or first
4497                MOVS    R9,R0             ; use of command line)
4498                LDMEQFD sp !,{r1-r3,r6,r9,PC} ; If malloc failed...
4499                CMN     R1,#-(-1)         ; Check for client buffer case
4500                BEQ     neednewbuffer     ; and don't share buffer if it is
4501                LDR     R14,[R12,#flags]
4502                TST     R14,#f_LocalHist  ; Check flag for multibuffer
4503                BNE     neednewbuffer     ; Local buffers, so create one
4504                LDR     R0,[R12,#head]
4505                TEQ     R0,#0             ; If we already have an instance,
4506                BNE     newinst_skip      ; copy its buffer
4507                TEQ     R1,#0             ; Just create an instance for
4508                BEQ     neednewbuffer     ; non-TaskWindows
4509                MOV     R0,#0
4510                MOV     R6,R1
4511                MOV     R1,R3             ; Buffer size
4512                BL      newinst
4513                MOV     R1,R6             ; Restore Task Handle to R1
4514                TEQ     R0,#0
4515                MOVEQ   R0,R9
4516                LDMEQFD sp !,{r1-r3,r6,r9,r14} ; If couldn't create cli inst
4517                BEQ     free
4518.newinst_skip   LDMIB   R0,{R2,R6,R14}    ; If global then copy buf, end,
4519                STMIA   R9,{R0,R2,R6,R14} ; and limit from first buffer
4520                B       nonewbuffer       ; and put old head into next
4521;
4522.neednewbuffer  MOV     R0,R3,ASL#10      ; Convert to Kbytes
4523                MOV     R2,R0
4524                BL      malloc
4525                TEQ     R0,#0
4526                MOVEQ   R0,R9
4527                LDMEQFD sp !,{r1-r3,r6,r9,r14} ; If malloc failed...
4528                BEQ     free
4529                ADD     R2,R0,R2
4530                STR     R2,[R9,#limit]
4531                STR     R0,[R9,#buf]
4532                MOV     R14,#0
4533                STRB    R14,[R0],#1
4534                STR     R0,[R9,#end]
4535.nonewbuffer    STR     R1,[R9,#taskh]    ; Task handle
4536                MOV     R0,#0
4537                STR     R0,[R9,#fkeybuf]  ; No fkey active
4538                STR     R0,[R9,#yankbuf]  ; No yank-able text
4539                STR     R0,[R9,#cur]      ; Inactive
4540                STR     R0,[R9,#r7]       ; No line
4541                STR     R0,[R9,#root]     ; No command completion tree
4542                CMN     R1,#-(-1)
4543                LDRNE   R0,[R12,#head]    ; Link into appropriate list
4544                LDREQ   R0,[R12,#morebufs]
4545                STR     R0,[R9,#next]
4546                STRNE   R9,[R12,#head]
4547                STREQ   R9,[R12,#morebufs]
4548                MOV     R0,R9             ; Return R0 pointing to current
4549                LDMFD   sp !,{r1-r3,r6,r9,PC} ; instance
4550.claimreadlinev STMFD   sp !,{R0-R2,R14}
4551                MOV     R0,#ReadLineV     ; Claim ReadLineV
4552                ADR     R1,myreadlinev
4553                MOV     R2,R12
4554                SWI     "XOS_Claim"
4555                LDMFD   sp !,{R0-R2,PC}
4556.relreadlinev   STMFD   sp !,{R0-R2,R14}
4557                MOV     R0,#ReadLineV     ; Release ReadLineV
4558                ADR     R1,myreadlinev
4559                MOV     R2,R12
4560                SWI     "XOS_Release"
4561                CMP     R0,R0
4562                LDMFD   sp !,{R0-R2,PC}
4563; Try to get a dynamic area
4564.alloc_init     STMFD   sp !,{r0-r8,r14}
4565                MOV     R0,#0    ; reason code- create
4566                MVN     R1,#NOT(-1)   ; number not specified
4567                MOV     R2,#0    ; initial size
4568                MVN     R3,#NOT(-1)   ; base not specified
4569                MOV     R4,#%10000010 ; not dragged, single mapped;
4570                                      ; cacheable, bufferable
4571                                      ; inaccessible in usr mode
4572                MOV     R5,#unison_area_max_size
4573                ADR     R6,area_handler
4574                MOV     R7,R12
4575                ADR     R8,area_title
4576                SWI     "XOS_DynamicArea"
4577                MOVVS   R3,#0 ; no dynamic areas it seems
4578                ADR     R0,area_info
4579                MOV     R4,#0     ; area_blocks
4580                STMIA   R0,{R1-R4}
4581                LDMFD   sp !,{r0-r8,PC}
4582; Delete a dynamic area if we've got one
4583.alloc_final    STMFD   sp !,{r0,r1,r2-r8,r14}
4584                LDR     R1,area_base
4585                TEQ     R1,#0
4586                MOVNE   R0,#0
4587                STRNE   R0,area_base
4588                LDRNE   R1,area_number
4589                MOVNE   R0,#1    ; reason code- delete
4590                SWINE   "XOS_DynamicArea"
4591                CMP     R0,R0
4592                LDMFD   sp !,{r0,r1,r2-r8,PC}
4593.area_info
4594.area_number    &    0 ; !HACK! these 4 need to be writable
4595.area_size      &    0
4596.area_base      &    0
4597.area_blocks    &    0
4598; *************************************** unison dynamic area handling code
4599.area_handler
4600  MOV   PC,R14
4601.area_title:= "LineEditor Buffers":= 0:FNalign
4602]
4603area_size_overhead = 64
4604area_block_overhead = 32
4605[OPT A%
4606  ; entry- R3 = required size
4607  ; exit-  R2 = pointer to claimed block
4608  ;        R3 preserved
4609.unison_alloc   STMFD   sp !,{R1,R3-R8,R14}
4610                LDR     R1,area_blocks
4611                CMP     R1,#0
4612                BLEQ    unison_alloc_init_heap
4613                BVS     unison_alloc_error
4614    ; attempt to allocate a block
4615.unison_alloc_alloc
4616                MOV     R0,#2     ; get heap block
4617                LDR     R1,area_base
4618    ; r3 set
4619                SWI     "XOS_Heap"
4620                BVS     unison_alloc_error
4621                CMP     R2,#0
4622                BVS     unison_alloc_failed
4623                LDR     R1,area_blocks
4624                ADD     R1,R1,#1
4625                STR     R1,area_blocks
4626                BL      unison_shrink_area
4627                LDMFD   sp !,{R1,R3-R8,PC}
4628.unison_alloc_failed
4629    ; attempt to add some more memory to the heap
4630                LDR     R0,area_number
4631                ADD     R1,R3,#area_block_overhead
4632                SWI     "XOS_ChangeDynamicArea"
4633    ; find out how large the dynamic area actually is
4634                LDRVC   R0,area_number
4635                SWIVC   "XOS_ReadDynamicArea"
4636                BVS     unison_alloc_error
4637                STMFD   sp !,{R3}
4638                LDR     R0,area_size
4639                STR     R1,area_size
4640                SUB     R3,R1,R0
4641                MOV     R0,#5    ; extend heap
4642                LDR     R1,area_base
4643                SWI     "XOS_Heap"
4644                LDMFD   sp !,{R3}
4645                BVC     unison_alloc_alloc
4646.unison_alloc_error
4647                LDR     R1,[R0]
4648                CMP     R1,#&184 ; ie no_room_in_heap_err
4649                BEQ     unison_alloc_failed
4650                SWI     "XOS_GenerateError"
4651                LDMFD   sp !,{R1,R3-R8,PC}
4652.unison_alloc_init_heap
4653                STMFD   sp !,{R1-R4,R14}
4654                LDR     R0,area_number
4655                ADD     R1,R3,#area_size_overhead       ; required size
4656                SWI     "XOS_ChangeDynamicArea"
4657                LDMVSFD sp !,{R1-R4,PC}
4658                STR     R1,area_size
4659                MOV     R3,R1
4660                MOV     R0,#0        ; initialise heap
4661                LDR     R1,area_base
4662                SWI     "XOS_Heap"
4663                LDMFD   sp !,{R1-R4,PC}
4664.unison_shrink_area
4665                STMFD   sp !,{R2-R3,R14}
4666                LDR     R8,area_size
4667                LDR     R1,area_blocks
4668                CMP     R1,#0    ; no block - size to zero
4669                BEQ     unison_shrink_area_vanish
4670                MOV     R0,#5    ; shrink heap
4671                LDR     R1,area_base
4672                RSB     R3,R8,#0
4673                SWI     "XOS_Heap"
4674;  LDMVSFD sp !,{R2-R3,PC}^
4675                ADDS    R14,R3,R8 ; (-r3==r8)?
4676                MOVEQ   R3,R8
4677 ; R3 = number of bytes the heap was shrunk by
4678                RSB     R1,R3,#0
4679                LDR     R0,area_number
4680                SWI     "XOS_ChangeDynamicArea"
4681                SUBVC   R8,R8,R1    ; r1 = bytes moved
4682                STRVC   R8,area_size
4683    ; change size of heap to reflect this new size
4684                SUBVC   R3,R3,R1     ; difference in bytes between the heap and the change in size of the dynamic area
4685                MOV     R0,#5
4686                LDR     R1,area_base
4687                SWI     "XOS_Heap"
4688                LDMFD   sp !,{R2-R3,PC}
4689.unison_shrink_area_vanish
4690                LDR     R0,area_number
4691                RSB     R1,R8,#0
4692                SWI     "XOS_ChangeDynamicArea"
4693                SUBVC   R8,R8,R1
4694                STRVC   R8,area_size
4695                LDMFD   sp !,{R2-R3,PC}
4696; /E R0=#bytes to allocate; /X R0->block or =0 if no room
4697; NB It seems that under RISC OS 2, OS_Module,6 can return R2=0, VC under
4698; some circumstances (RKL hit this problem) - this routine copes
4699.malloc         STMFD   sp !,{R1,R2,R3,R14}
4700                MOV     R3,R0
4701                LDR     R1,area_base
4702                CMP     R1,#0
4703                BNE     dynmalloc
4704                MOV     R0,#6
4705                SWI     "XOS_Module"
4706.mallocback     MOVVC   R0,R2
4707                MOVVS   R0,#0
4708                LDMFD   sp !,{R1,R2,R3,PC}
4709;
4710.dynmalloc      BL      unison_alloc
4711                B       mallocback
4712; /E R0->block to free or =0 (ignored), /X R0=0 [useful for zeroing ptrs]
4713; *** NB returns 0 (C free doesn't) ***
4714.free           STMFD   sp !,{R1,R2,R14}
4715                MOVS    R2,R0
4716                BEQ     free_null
4717                LDR     R1,area_base
4718                CMP     R1,#0
4719                BNE     dynfree
4720                MOV     R0,#7
4721                SWI     "XOS_Module"
4722.free_null      MOV     R0,#0
4723                LDMFD   sp !,{R1,R2,PC}
4724;
4725; R1 = area_base
4726; R2 = pointer to block to free
4727.dynfree        STMFD   sp !,{R3-R8}
4728                MOV     R0,#3     ; free block
4729                SWI     "XOS_Heap"
4730                LDRVC   R1,area_blocks
4731                SUBVC   R1,R1,#1
4732                STRVC   R1,area_blocks
4733                BLVC    unison_shrink_area
4734                LDMFD   sp !,{R3-R8}
4735                B       free_null
4736; /E r0,r1 = chars to teq; /X Z set appropriately, other flags, r1 undef'd
4737.caselessteq    STMFD   sp !,{r14}
4738                LDR     r14,[r12,#upcasetable]
4739                TEQ     r14,#0
4740                BEQ     caselessteq_old
4741                LDRB    r0,[r14,r0]
4742                LDRB    r1,[r14,r1]
4743                TEQ     r0,r1
4744                LDMFD   sp !,{pc}
4745.caselessteq_old
4746                EORS    r1,r0,r1
4747                LDMEQFD sp !,{pc}          ; Simple - exact match
4748                TEQ     r1,#32
4749                LDMNEFD sp !,{pc}          ; Simplish - can't match
4750                BIC     r0,r0,#32
4751                CMP     r0,#ASC"Z"
4752                RSBLTS  r1,r0,#ASC"A"
4753                TSTLT   r0,#0              ; If LT, then force EQ
4754                LDMFD   sp !,{pc}
4755.caselessteq_init
4756 STMFD   sp !,{R0,R1,R14}
4757 MVN     r0,#0 ; -1
4758 SWI     "XTerritory_UpperCaseTable"
4759 MOVVS   r0,#0
4760 STR     r0,[r12,#upcasetable]
4761 LDMFD   sp !,{R0,R1,PC}
4762]
4763IF debug% THEN
4764[OPT A%
4765.dump           STMFD   sp !,{R12,R14}
4766                MOV     R12,sp
4767                BL      recall
4768                LDMFD   sp !,{R12,PC}
4769.showregs       STMFD   sp !,{R0,R14}      ; Change offset on r13 below if
4770                STMFD   sp !,{R1}          ; stacking changed
4771                STMFD   sp !,{R2}
4772                MOV     R2,R14
4773                SWI     XOS_NewLine
4774                SWI     XOS_WriteI+ASC"R"
4775                SWI     XOS_WriteI+ASC"0"
4776                SWI     XOS_WriteI+ASC" "
4777                SWI     XOS_WriteI+ASC" "
4778                BL      outhex
4779                SWI     XOS_WriteI+ASC" "
4780                SWI     XOS_WriteI+ASC"R"
4781                SWI     XOS_WriteI+ASC"1"
4782                SWI     XOS_WriteI+ASC" "
4783                SWI     XOS_WriteI+ASC" "
4784                MOV     R0,R1
4785                BL      outhex
4786                SWI     XOS_WriteI+ASC" "
4787                MOV     R1,R2
4788                LDMFD   sp !,{R2}
4789]
4790FOR l%=2 TO9
4791[OPT A%
4792                SWI     XOS_WriteI+ASC"R"
4793                SWI     XOS_WriteI+ASC"0"+l%
4794                SWI     XOS_WriteI+ASC" "
4795                SWI     XOS_WriteI+ASC" "
4796                MOV     R0,l%
4797                BL      outhex
4798]
4799IF (l%AND3)=3 THEN
4800[OPT A%
4801                SWI     XOS_NewLine
4802]
4803ELSE
4804[OPT A%
4805                SWI     XOS_WriteI+ASC" "
4806]
4807ENDIF
4808NEXT
4809FOR l%=10 TO13
4810[OPT A%
4811                SWI     XOS_WriteI+ASC"R"
4812                SWI     XOS_WriteI+ASC"1"
4813                SWI     XOS_WriteI+ASC"0"+l%-10
4814                SWI     XOS_WriteI+ASC" "
4815                ADD     R0,l%,#(-12*(l%=13)) ; Offset for stack pointer
4816                BL      outhex
4817]
4818IF (l%AND3)=3 THEN
4819[OPT A%
4820                SWI     XOS_NewLine
4821]
4822ELSE
4823[OPT A%
4824                SWI     XOS_WriteI+ASC" "
4825]
4826ENDIF
4827NEXT
4828[OPT A%
4829                SWI     XOS_WriteI+ASC"P"
4830                SWI     XOS_WriteI+ASC"C"
4831                SWI     XOS_WriteI+ASC" "
4832                SWI     XOS_WriteI+ASC" "
4833                MOV     R0,R1 ; R14 on entry
4834                BL      outhex
4835                SWI     XOS_NewLine
4836                LDMFD   sp !,{R1}
4837                LDMFD   sp !,{R0,PC}
4838.outhex         STMFD   sp !,{R0-R2,R14}
4839                SUB     sp,sp,#12
4840                MOV     R1,sp
4841                MOV     R2,#9
4842                SWI     "XOS_ConvertHex8"
4843                SWIVC   XOS_Write0
4844                ADD     sp,sp,#12
4845                LDMFD   sp !,{R0-R2,PC}
4846]
4847ENDIF
4848[OPT A%
4849;.editorhelp     ADR     R0,szeditorhelp
4850.pprinthelp     MOV     R6,R14
4851                BL      pprint
4852                MOV     R0,#0
4853                MOV     PC,R6
4854;.szeditorhelp   FNpp(   "This module replaces the RISC OS OS_ReadLine ")
4855;                FNpp(   "routine and allows recall and editing of ")
4856;                FNpp(   "previously entered lines. ")
4857]
4858IF small THEN
4859 [OPT A%:  ;     FNpp("See the !Help file for more info."+cr$):]
4860ELSE
4861 [OPT A%:  ;     FNlonghelp:]
4862ENDIF
4863[OPT A%:   ;     EQUB 0:FNalign
4864.jmptab         FNkeytab
4865]NEXT:T%=TIME
4866FOR N%=1 TOM%:PRINT U%(N%),N%(N%),(U%(N%)+N%(N%)-1)*(LEN K$(N%)-2)-4,K$(N%):NEXT
4867SYS "OS_GetEnv" TO P$
4868I%=INSTR(P$,"-quit ")
4869IF I% THEN
4870 P$=MID$(P$,I%+6):WHILE LEFT$(P$,1)=" ":P$=MID$(P$,2):ENDWHILE
4871 I%=INSTR(P$," "):IF I% P$=LEFT$(P$,I%-1):IF LEFT$(P$,1)="""" P$=MID$(P$,2)
4872 J%=0:REPEAT I%=J%:J%=INSTR(P$,".",I%+1):UNTIL J%=0
4873 IF I% P$=LEFT$(P$,I%)
4874ELSE P$=""
4875ENDIF
4876PRINT"'"P$"'"
4877SYS "OS_File",&0A,P$+fnm$,&FFA,,org,O%
4878PROCoutkeys
4879PRINT'vsn$'
4880IF debug% PRINT"*** Assembled with debugging code ***"'
4881PRINT"Size = ";P%" bytes, Time = ";T%/100;" seconds, Speed = ";INT(P%/T%*100+.5);" bytes/sec"
4882REM SYS "OS_Module",11,org,P%
4883PRINT"*** _NOT_ loading module into RMA"
4884END
4885DEF PROCinitdict:LOCAL I%,N%
4886DIM K$(256),D$(256),U%(256),N%(256)
4887N%=0:REPEAT N%+=1:READ C$:I%=INSTR(C$,"~")
4888WHILE I%:C$=LEFT$(C$,I%-1)+cr$+MID$(C$,I%+1):I%=INSTR(C$,"~"):ENDWHILE
4889D$(N%)=C$:UNTIL C$="":M%=N%-1
4890FOR N%=M% TO 1 STEP -1
4891 K$="":S%=1
4892 REPEAT
4893  I%=INSTR(D$(N%),"")
4894  IF I% THEN
4895   J%=INSTR(D$(N%),"",I%+1):IF J%=0 PRINT"Mismatched  in dictionary":STOP
4896   L$=LEFT$(D$(N%),I%-1):R$=MID$(D$(N%),J%+1)
4897   IF J%>I%+1 THEN
4898    T$=MID$(D$(N%),I%+1,J%-I%-1):K%=N%+1
4899    WHILE T$<>K$(K%):K%+=1:IF K%>M% PRINT"Bad nested dictionary tokens":STOP
4900    ENDWHILE
4901    K$+=MID$(D$(N%),S%,I%-S%)+T$:S%=J%+1-LEN T$
4902    D$(N%)=L$+esc$+CHR$ K%+R$:N%(K%)+=1
4903   ELSE K$+=esc$+CHR$0:S%=J%+1:D$(N%)=L$+esc$+CHR$0+R$
4904   ENDIF
4905  ENDIF
4906 UNTIL I%=0
4907 REPEAT I%=INSTR(K$,"  "):IF I% K$=LEFT$(K$,I%)+MID$(K$,I%+2)
4908 UNTIL I%=0
4909 K$(N%)=K$+MID$(D$(N%),S%)
4910NEXT
4911ENDPROC
4912DEF FNh(K$,D$):[OPTA%:FNpp(K$+STRING$((24-LEN K$+7)DIV8,tab$)+D$+"."+cr$):]:=0
4913DEF FNlonghelp
4914[OPT A%
4915FNpp("The "+prog$+" supports the following keys:"+cr$)
4916FNh("Esc, ^[","Abandon current line and do not insert in buffer")
4917FNh("Tab, ^I","Complete filename (beeps if no unique match)")
4918FNh("Tab / ^Tab","Step forwards/backwards through completions of filename")
4919FNh("Insert","Toggle insert/overtype mode (for current line only)")
4920FNh("Copy, Copy","Allow normal screen copying (for current line only)")
4921FNh("Insert","Clear and remove single line from history")
4922FNh("Delete, <-|, ^H","Delete left")
4923FNh("Delete, ^D","Delete right")
4924FNh("^D","Delete to end of word")
4925FNh("^Delete / ^Delete","Clear line and erase this/all history buffer(s)")
4926FNh("Up, ^P / Down, ^N","Cycle backwards/forwards through previous lines")
4927FNh("Left, ^B / Right, ^F","Move cursor left/right by one character")
4928FNh("Left / Right","Move cursor to end/start of previous/next word")
4929FNh("PageUp, Up","Step backwards through lines with start matching")
4930FNh("PageDown, Down","Step forwards through lines with start matching")
4931FNh("^Up / ^Down","Recall the oldest/newest previous line")
4932FNh("^Left, ^A / ^Right, ^E","Move cursor to start/end of line")
4933FNh("Return, Enter, ^M","Finish entering line")
4934FNh("^J","Like Return, but doesn't store line in history")
4935FNh("^U","Clear entire line")
4936FNh("^K","Clear to end of line")
4937FNh("^@","Set mark")
4938FNh("^X","Exchange mark and cursor")
4939FNh("^W","Delete region between mark and cursor")
4940FNh("^Y","Yank back last text deleted with ^K or ^W")
4941FNh("^T","Transpose character at cursor with character to left")
4942FNh("^Q","Quote next keystroke (eg ^Q^N for paged scrolling)")
4943FNpp(   "All other control codes are echoed to the screen, but not put ")
4944FNpp(   "in the history buffer."+cr$)
4945FNpp(   "~<string> recalls line whose start uniquely matches <string>.")
4946]:=0
4947DEF FNalign
4948IF (P%AND3) THEN
4949 REM IF (A%AND2)=0 OR (A%AND1) PRINT;4-(P%AND3)" byte(s) wasted by FNalign"
4950 [OPT(A%ANDNOT1):= STRING$(4-(P%AND3),bl$):]
4951ENDIF
4952=0
4953DEF FNdict(A$):[OPT(A%ANDNOT1):= LEN A$+2:= A$:= 0:]:=0
4954DEF FNtab(B%,Z%):LOCAL V%:IF B%<P%-jmptab PRINT"cockup in key table":STOP
4955V%=(Z%-base)DIV4:IF V%>255 PRINT"value for table too big":STOP
4956IF V%<0 PRINT"value for table too small":STOP
4957[OPT(A%ANDNOT1):= STRING$(B%-(P%-jmptab),CHR$((vanilla-base)DIV4)):= V%:]
4958=0
4959DEF FNtb2(B%,C%,Z%):LOCAL V%:IF B%<P%-jmptab PRINT"cockup in key table":STOP
4960V%=(Z%-base)DIV4:IF V%>255 PRINT"value for table too big":STOP
4961IF V%<0 PRINT"value for table too small":STOP
4962IF C%<B% PRINT"range is empty":STOP
4963[OPT(A%ANDNOT1):= STRING$(B%-(P%-jmptab),CHR$((vanilla-base)DIV4))
4964= STRING$(C%-B%+1,CHR$ V%):]:=0
4965DEF FNpp(S$)
4966REM[OPT(A%ANDNOT1):= S$:]:=0
4967REM IF (A%AND2) PRINTS$
4968LOCAL N%,I%,K$,f%,J%,l%
4969REPEAT
4970 N%=0
4971 REPEAT
4972  N%+=1:K$=K$(N%):l%=LEN K$
4973  I%=INSTR(S$,K$)
4974  IF I%=0 AND RIGHT$(K$)=" " THEN
4975   I%=INSTR(S$,LEFT$(K$)+esc$)
4976   IF I% THEN
4977    f%=ASC(K$(ASC(MID$(S$,I%+LEN K$,1))))
4978    IF f%=32 OR f%=9 l%-=1 ELSE I%=0
4979   ENDIF
4980  ENDIF
4981  IF I%=0 AND LEFT$(K$,1)=" " THEN
4982   K$=MID$(K$,2)
4983   J%=0
4984   REPEAT
4985    J%=INSTR(S$,K$,J%+1)
4986    f%=(MID$(S$,J%-2,1)=esc$)
4987    IF f% IF RIGHT$(K$(ASC MID$(S$,J%-1,1)))=" " I%=J%
4988   UNTIL I% OR J%=0
4989   IF I%=0 AND RIGHT$(K$)=" " THEN
4990    K$=LEFT$(K$)
4991    J%=0
4992    REPEAT
4993     J%=INSTR(S$,K$+esc$,J%+1)
4994     f%=(MID$(S$,J%-2,1)=esc$)
4995     IF f% IF RIGHT$(K$(ASC MID$(S$,J%-1,1)))=" " I%=J%
4996     IF I% THEN
4997      f%=ASC(K$(ASC(MID$(S$,I%+LEN K$+1,1))))
4998      IF f%=32 OR f%=9 ELSE I%=0
4999     ENDIF
5000    UNTIL I% OR J%=0
5001   ENDIF
5002   l%=LEN K$
5003  ENDIF
5004 UNTIL I% OR N%=M%
5005 IF I% S$=LEFT$(S$,I%-1)+esc$+CHR$ N%+MID$(S$,I%+l%):IF (A%AND2) U%(N%)+=1
5006UNTIL I%=0
5007[OPT(A%ANDNOT1):= S$:]
5008REM IF (A%AND2) THEN SYS "OS_PrettyPrint",S$+CHR$0,ppdict+org,"xxxx"
5009=0
5010DEF PROCerr
5011ON ERROR OFF
5012ERROR ERR,REPORT$+" at line "+STR$ ERL
5013ENDPROC
5014REM Use ~ for CR
5015DATA "Syntax: *"
5016DATA " (for current  line only)"
5017DATA "s with start matching."
5018DATA " mark and  cursor"
5019DATA " history buffer"
5020DATA "wards through "
5021DATA " Line Editor "
5022DATA "overtype mode"
5023DATA "*Configure Ed"
5024DATA "Move cursor "
5025DATA " completion"
5026DATA " character "
5027DATA " displays "
5028DATA "underscore"
5029DATA " to end of "
5030DATA " contents "
5031DATA "	Flashing "
5032DATA " previous"
5033DATA " current "
5034DATA "filename"
5035DATA "Return, "
5036DATA "Syntax: "
5037DATA "	Steady "
5038DATA "default"
5039DATA "RISC OS"
5040DATA " cursor"
5041DATA " set: "
5042REM DATA "Up/Down"
5043DATA "Delete"
5044DATA "Clear "
5045DATA " sets "
5046REM DATA " erase"
5047DATA "nsert"
5048DATA " line"
5049DATA " and "
5050DATA " the "
5051DATA "Step "
5052DATA "~bit "
5053REM DATA "Page"
5054DATA "ight"
5055DATA "Down"
5056DATA " to "
5057DATA " of "
5058REM was nestedDATA "for "
5059DATA "lags"
5060DATA "eft"
5061DATA ""
5062DEF FNkeytab
5063[OPT A%
5064; Unused Ctrl-<key> combinations GLORSVZ\]_ (^I could be reclaimed)
5065    FNtab(&000,setmark)      ; cSpace
5066    FNtab(&001,gotostart)    ; cA
5067    FNtab(&002,left)         ; cB
5068    FNtab(&003,showcomp)     ; cC
5069    FNtab(&004,deleteright)  ; cD
5070    FNtab(&005,gotoend)      ; cE
5071    FNtab(&006,right)        ; cF
5072    FNtab(&008,deleteleft)   ; cH
5073    FNtab(&009,dotcshcomp)   ; cI       ; Try tcsh fnm complet'n
5074    FNtab(&00A,return)       ; cJ
5075    FNtab(&00B,killeol)      ; cK
5076    FNtab(&00D,enter)        ; cM
5077    FNtab(&00E,downhistreq)  ; cN       ; Recall next line
5078    FNtab(&00F,copy);fileropen)    ; cO
5079    FNtab(&010,uphistreq)    ; cP       ; Recall previous line
5080    FNtab(&011,quote)        ; cQ
5081    FNtab(&014,transpose)    ; cT
5082    FNtab(&015,delline)      ; cU
5083    FNtab(&017,wipe)         ; cW
5084    FNtab(&018,swapmarkcursor);cX
5085    FNtab(&019,yank)         ; cY
5086    FNtab(&01B,escape)       ; ESCAPE
5087    FNtab(&01C,deleteleft)   ; <-|
5088    FNtab(&01D,enter)        ; RETURN
5089    FNtab(&01E,gotostart)    ; HOME
5090    FNtab(&01F,wipehistory)  ; cDELETE
5091    FNtb2(&020,&07E,vanilla) ; SPACE-~
5092    FNtab(&07F,deleteleft)   ; DELETE
5093;OL FNtab(&07F,deleteright)  ; DELETE
5094    FNtb2(&080,&0FF,vanilla) ; top bit set characters
5095    FNtab(&104,delword)      ; scD
5096    FNtab(&10A,enter)        ; scJ
5097    FNtab(&10C,vanilla)      ; scL
5098    FNtab(&10E,vanilla)      ; scN
5099    FNtab(&10F,vanilla)      ; scO
5100    FNtab(&114,vanilla)      ; scT
5101    FNtab(&11A,vanilla)      ; scZ
5102    FNtab(&11D,vanilla)      ; sRETURN
5103    FNtab(&11F,wipeallhistory);scDELETE
5104    FNtab(&120,vanilla)      ; sSPACE
5105    FNtab(&12B,escape)       ; c[
5106    FNtab(&13D,vanilla)      ; cRETURN
5107    FNtab(&152,setmark)      ; sc2
5108    FNtab(&15D,vanilla)      ; scRETURN
5109    FNtb2(&161,&165,vanilla) ; k/-k+
5110    FNtab(&166,enter)        ; kEnter
5111    FNtab(&167,vanilla)      ; k.
5112    FNtab(&17F,deleteright)  ; sDELETE
5113    FNtb2(&180,&189,fnkey)   ; F0-F9
5114    FNtab(&18A,dotcshcompshow);TAB      ; Try tcsh fnm complet'n
5115    FNtab(&18B,copy)         ; COPY/END
5116    FNtab(&18C,left)         ; LEFT
5117    FNtab(&18D,right)        ; RIGHT
5118    FNtab(&18E,downhistreq)  ; DOWN     ; Recall next line
5119    FNtab(&18F,uphistreq)    ; UP       ; Recall previous line
5120    FNtab(&19A,completenext) ; sTAB     ; Try 4DOS fnm complet'n
5121    FNtab(&19B,copy)         ; sCOPY    [like !Zap]
5122    FNtab(&19C,prevword)     ; sLEFT
5123    FNtab(&19D,nextword)     ; sRIGHT
5124    FNtab(&19E,dnhistmatch)  ; sDOWN
5125    FNtab(&19F,uphistmatch)  ; sUP
5126    FNtab(&1AB,gotoend)      ; cCOPY
5127    FNtab(&1AC,gotostart)    ; cLEFT
5128    FNtab(&1AD,gotoend)      ; cRIGHT
5129    FNtab(&1AE,cdown)        ; cDOWN
5130    FNtab(&1AF,oldesthist)   ; cUP
5131    FNtab(&1BA,completeprev) ; scTAB    ; Try 4DOS fnm complet'n
5132    FNtb2(&1CA,&1CC,fnkey)   ; F10-F12
5133    FNtab(&1CD,toggleinsert) ; INSERT
5134    FNtab(&1DD,removeline)   ; sINSERT
5135    FNtab(&1FF,vanilla)      ; forces generation of end of table
5136]
5137=0
5138DEF PROCoutkeys
5139LOCAL N%,O%,L%,A$,V%,BLI%
5140BLI%=10000
5141READ N%
5142O%=OPENOUT(P$+"KeyLib")
5143BPUT#O%,"BASIC -load "+P$+"RebindBase"
5144REM BPUT#O%,"AU. 10000"
5145REM BPUT#O%,"REM >KEYLIB"
5146BPUT#O%,STR$(BLI%)+"DATA "+vsn$     : BLI%=BLI%+10
5147BPUT#O%,STR$(BLI%)+"DATA "+STR$ N%  : BLI%=BLI%+10
5148FOR L%=0 TO N%-1
5149 READ A$:PRINT A$
5150 BPUT#O%,STR$(BLI%)+" DATA "+A$+","+STR$((EVAL A$-base)/4)
5151 BLI%=BLI%+10
5152NEXT
5153BPUT#O%,"SAVE """+P$+"Rebinder"""
5154BPUT#O%,"QUIT"
5155BPUT#O%,"/"+P$+"RebindKeys"
5156BPUT#O%,"":REM to accept default
5157REM can't as I'm still open... BPUT#O%,"delete "+P$+"KeyLib"
5158BPUT#O%,"ShellCLI_TaskQuit":REM ... so do this instead
5159CLOSE #O%
5160SYS "OS_File",18,P$+"KeyLib",&FFE:REM Command.. orig was FD6=TaskExec
5161OSCLI "/"+P$+"KeyLib"
5162ENDPROC
5163DEF FNshowreg( R% )
5164[OPT A%
5165STR R0,P%+20
5166STR R14,P%+20
5167MOV R0,R%
5168ADR R14,P%+16
5169B   outhex
5170& 0:& 0
5171LDR R0,P%-8
5172LDR R14,P%-8
5173]
5174=0
5175DEF FNtrace(m$)
5176IF trace% THEN
5177[OPT A%
5178STMFD    sp !,{r0}
5179SWI      XOS_WriteS
5180= m$+lfcr$+bl$
5181FNalign
5182LDMFD    sp !,{r0}
5183]
5184ENDIF
5185=0
5186DEF FNassert(a$)
5187IF EVAL a$ ELSE PRINT "Assertion '"a$"' failed":STOP
5188=0
5189DEF FNADRL(R%,T%)
5190LOCAL H%:IF T% AND 3 THEN H%=255:ELSE H%=1023
5191PRINT ~P% T%;
5192H%=(T% AND NOT H%)+(P%+8 AND H%):T%-=H%
5193PRINT ~H% T% H%+T%
5194IF T%>=0 THEN [OPT A%:ADR R%,H%:ADD R%,R%,#T%:]=0
5195[OPT A%:ADR R%,H%:SUB R%,R%,#-T%
5196]=0
5197DATA 42
5198DATA ignore, beepignore, left, right, delword, cright, cleft, sright, sleft
5199DATA toggleinsert, delline, removeline, complete, completenext, completeprev
5200DATA setmark, copy, swapmark, cut, deletenext, delete, wipehistory, deltoend
5201DATA paste, swapchars, quote, vanilla, cup, cdown, up, down, sup, sdown
5202DATA escape, fnkey, wipeallhistory, enter, return, uncopy
5203DATA showcomp, completeshow, fileropen
